<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="structfaiss_1_1IndexRowwiseMinMaxBase" kind="struct" language="C++" prot="public" abstract="yes">
    <compoundname>faiss::IndexRowwiseMinMaxBase</compoundname>
    <basecompoundref refid="structfaiss_1_1Index" prot="public" virt="non-virtual">faiss::Index</basecompoundref>
    <derivedcompoundref refid="structfaiss_1_1IndexRowwiseMinMax" prot="public" virt="non-virtual">faiss::IndexRowwiseMinMax</derivedcompoundref>
    <derivedcompoundref refid="structfaiss_1_1IndexRowwiseMinMaxFP16" prot="public" virt="non-virtual">faiss::IndexRowwiseMinMaxFP16</derivedcompoundref>
    <includes refid="IndexRowwiseMinMax_8h" local="no">IndexRowwiseMinMax.h</includes>
    <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="structfaiss_1_1IndexRowwiseMinMaxBase_1a6def68df271f8809c1ed2cfa3107f082" prot="public" static="no" mutable="no">
        <type><ref refid="structfaiss_1_1Index" kindref="compound">Index</ref> *</type>
        <definition>Index* faiss::IndexRowwiseMinMaxBase::index</definition>
        <argsstring></argsstring>
        <name>index</name>
        <qualifiedname>faiss::IndexRowwiseMinMaxBase::index</qualifiedname>
        <briefdescription>
<para>sub-index </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexRowwiseMinMax.h" line="43" column="11" bodyfile="faiss/IndexRowwiseMinMax.h" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfaiss_1_1IndexRowwiseMinMaxBase_1accffd820463f8e8021de397974d8daba" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool faiss::IndexRowwiseMinMaxBase::own_fields</definition>
        <argsstring></argsstring>
        <name>own_fields</name>
        <qualifiedname>faiss::IndexRowwiseMinMaxBase::own_fields</qualifiedname>
        <briefdescription>
<para>whether the subindex needs to be freed in the destructor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexRowwiseMinMax.h" line="46" column="10" bodyfile="faiss/IndexRowwiseMinMax.h" bodystart="46" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfaiss_1_1Index_1a2a002388d2c081c2dbab8508dcefe73d" prot="public" static="no" mutable="no">
        <type>int</type>
        <definition>int faiss::Index::d</definition>
        <argsstring></argsstring>
        <name>d</name>
        <qualifiedname>faiss::Index::d</qualifiedname>
        <briefdescription>
<para>vector dimension </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="103" column="9" bodyfile="faiss/Index.h" bodystart="103" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfaiss_1_1Index_1a6970683faa021b7a6f1a0865c0d4eccd" prot="public" static="no" mutable="no">
        <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
        <definition>idx_t faiss::Index::ntotal</definition>
        <argsstring></argsstring>
        <name>ntotal</name>
        <qualifiedname>faiss::Index::ntotal</qualifiedname>
        <briefdescription>
<para>total nb of indexed vectors </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="104" column="11" bodyfile="faiss/Index.h" bodystart="104" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfaiss_1_1Index_1a5590d847c5c2b958affd2a05e58a6f23" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool faiss::Index::verbose</definition>
        <argsstring></argsstring>
        <name>verbose</name>
        <qualifiedname>faiss::Index::verbose</qualifiedname>
        <briefdescription>
<para>verbosity level </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="105" column="10" bodyfile="faiss/Index.h" bodystart="105" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfaiss_1_1Index_1a6e92732617c4dbe364e7678dd8773a7f" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool faiss::Index::is_trained</definition>
        <argsstring></argsstring>
        <name>is_trained</name>
        <qualifiedname>faiss::Index::is_trained</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>set if the <ref refid="structfaiss_1_1Index" kindref="compound">Index</ref> does not require training, or if training is done already </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="109" column="10" bodyfile="faiss/Index.h" bodystart="109" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfaiss_1_1Index_1a8e18f641854b2bde83ecff0a2f9a6f4e" prot="public" static="no" mutable="no">
        <type><ref refid="namespacefaiss_1afd12191c638da74760ff397cf319752c" kindref="member">MetricType</ref></type>
        <definition>MetricType faiss::Index::metric_type</definition>
        <argsstring></argsstring>
        <name>metric_type</name>
        <qualifiedname>faiss::Index::metric_type</qualifiedname>
        <briefdescription>
<para>type of metric this index uses for search </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="112" column="16" bodyfile="faiss/Index.h" bodystart="112" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfaiss_1_1Index_1a6f60646d6877658ea4df05e0231ed232" prot="public" static="no" mutable="no">
        <type>float</type>
        <definition>float faiss::Index::metric_arg</definition>
        <argsstring></argsstring>
        <name>metric_arg</name>
        <qualifiedname>faiss::Index::metric_arg</qualifiedname>
        <briefdescription>
<para>argument of the metric type </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="113" column="11" bodyfile="faiss/Index.h" bodystart="113" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="structfaiss_1_1IndexRowwiseMinMaxBase_1add65ec81582758713652b40bef00b024" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>faiss::IndexRowwiseMinMaxBase::IndexRowwiseMinMaxBase</definition>
        <argsstring>(Index *index)</argsstring>
        <name>IndexRowwiseMinMaxBase</name>
        <qualifiedname>faiss::IndexRowwiseMinMaxBase::IndexRowwiseMinMaxBase</qualifiedname>
        <param>
          <type><ref refid="structfaiss_1_1Index" kindref="compound">Index</ref> *</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexRowwiseMinMax.h" line="48" column="14"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexRowwiseMinMaxBase_1a4f20ffb075b81b0bee2f74b6aea0773b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>faiss::IndexRowwiseMinMaxBase::IndexRowwiseMinMaxBase</definition>
        <argsstring>()</argsstring>
        <name>IndexRowwiseMinMaxBase</name>
        <qualifiedname>faiss::IndexRowwiseMinMaxBase::IndexRowwiseMinMaxBase</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexRowwiseMinMax.h" line="50" column="5"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexRowwiseMinMaxBase_1a6a5b2154c5736881a4ee75b7b6488b2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>faiss::IndexRowwiseMinMaxBase::~IndexRowwiseMinMaxBase</definition>
        <argsstring>() override</argsstring>
        <name>~IndexRowwiseMinMaxBase</name>
        <qualifiedname>faiss::IndexRowwiseMinMaxBase::~IndexRowwiseMinMaxBase</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexRowwiseMinMax.h" line="51" column="5"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexRowwiseMinMaxBase_1a2c727d28e4d8dc5eedfbea69695cf323" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void faiss::IndexRowwiseMinMaxBase::add</definition>
        <argsstring>(idx_t n, const float *x) override</argsstring>
        <name>add</name>
        <qualifiedname>faiss::IndexRowwiseMinMaxBase::add</qualifiedname>
        <reimplements refid="structfaiss_1_1Index_1a1b5e9ac70adbce0897dd6c8276ad96f2">add</reimplements>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const float *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add n vectors of dimension d to the index.</para>
<para>Vectors are implicitly assigned labels ntotal .. ntotal + n - 1 This function slices the input vectors in chunks smaller than blocksize_add and calls add_core. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>input matrix, size n * d </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexRowwiseMinMax.h" line="53" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexRowwiseMinMaxBase_1a4f41c5ae635cb0980607c9428a388879" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void faiss::IndexRowwiseMinMaxBase::search</definition>
        <argsstring>(idx_t n, const float *x, idx_t k, float *distances, idx_t *labels, const SearchParameters *params=nullptr) const override</argsstring>
        <name>search</name>
        <qualifiedname>faiss::IndexRowwiseMinMaxBase::search</qualifiedname>
        <reimplements refid="structfaiss_1_1Index_1a4bec1a04796e20ea0bfa24bad5b246e3">search</reimplements>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const float *</type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>distances</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref> *</type>
          <declname>labels</declname>
        </param>
        <param>
          <type>const <ref refid="structfaiss_1_1SearchParameters" kindref="compound">SearchParameters</ref> *</type>
          <declname>params</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>query n vectors of dimension d to the index.</para>
<para>return at most k vectors. If there are not enough results for a query, the result array is padded with -1s.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>input vectors to search, size n * d </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k</parametername>
</parameternamelist>
<parameterdescription>
<para>number of extracted vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>distances</parametername>
</parameternamelist>
<parameterdescription>
<para>output pairwise distances, size n*k </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>labels</parametername>
</parameternamelist>
<parameterdescription>
<para>output labels of the NNs, size n*k </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexRowwiseMinMax.h" line="54" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexRowwiseMinMaxBase_1ae2ae0c124b00ce684b6f2195061102f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void faiss::IndexRowwiseMinMaxBase::reset</definition>
        <argsstring>() override</argsstring>
        <name>reset</name>
        <qualifiedname>faiss::IndexRowwiseMinMaxBase::reset</qualifiedname>
        <reimplements refid="structfaiss_1_1Index_1a849361f5f0ab0aba8d419c86f2594191">reset</reimplements>
        <briefdescription>
<para>removes all elements from the database. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexRowwiseMinMax.h" line="62" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexRowwiseMinMaxBase_1a594aec2b7bf912824b6d1559ecf85c34" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void faiss::IndexRowwiseMinMaxBase::train_inplace</definition>
        <argsstring>(idx_t n, float *x)=0</argsstring>
        <name>train_inplace</name>
        <qualifiedname>faiss::IndexRowwiseMinMaxBase::train_inplace</qualifiedname>
        <reimplementedby refid="structfaiss_1_1IndexRowwiseMinMaxFP16_1a5de06c17fe61592f4a24ac7dd77a6008">train_inplace</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRowwiseMinMax_1a110aae6e48f7e1a31792c99961d65c38">train_inplace</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexRowwiseMinMax.h" line="64" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a8f67dfd73993e192dc78f2c93d9d9532" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::train</definition>
        <argsstring>(idx_t n, const float *x)</argsstring>
        <name>train</name>
        <qualifiedname>faiss::Index::train</qualifiedname>
        <reimplementedby refid="structfaiss_1_1gpu_1_1GpuIndexCagra_1ac722f952671b1c16ffeb6c35c9bf9319">train</reimplementedby>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndexFlat_1a4de68542fac496ecd0be85a25ecdb0d6">train</reimplementedby>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndexIVFFlat_1a174853bbcb2c8760f9b10c7dd638827e">train</reimplementedby>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndexIVFPQ_1a83f32135cda2a3e4251737d2eb245324">train</reimplementedby>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndexIVFScalarQuantizer_1a8e7f71bba75829a5d7d503ac8e5692e8">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1Index2Layer_1a48cbf519590313f1c6a3dc89c8d0678c">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexResidualQuantizer_1a1870bea9540fe4cb8308c09104048332">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexLocalSearchQuantizer_1aa63fc9328d0f202707f9fc947cc423f4">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexProductResidualQuantizer_1a726a1a837bea21c65e9974499e838fd6">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexProductLocalSearchQuantizer_1aa165f6c8c6655052a39bbad89b1dd8d7">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1AdditiveCoarseQuantizer_1a150b455e4152bc63ae4f51ba44405475">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexAdditiveQuantizerFastScan_1ac209f095ccac62ca6cc86d24923471d3">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexHNSW_1a40bc6d2c67545f95e322c63d68a47140">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexHNSWPQ_1ae99b976eeb25717d10055b1786aa011c">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1a7a1d5eec194db0977b2318c6ed6a2b86">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFFlatDedup_1a24002a8c3f12aa2784833c14b13b427e">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFIndependentQuantizer_1a49b9e45f584db588148707889a9c96c1">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexLattice_1a19a6d0136b34d904d147f16922a64b93">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexLSH_1a01f569a16a812aa3945b8a0b64eaff06">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexNeuralNetCodec_1ab8fc8d69687d1c8055016045405e7691">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexNNDescent_1a11e65f02f9edb9c09fc0152486b96aff">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexNSG_1a024c25f4757df14fb741ca9a6fb4cfcb">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexNSGPQ_1afa79e49f634ed87c0f597b9d9fc2f111">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPQ_1a87898add5ab4d86ba901ca79778fc11e">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1MultiIndexQuantizer_1a6fa1d1a295eb2d4377b8de5096ab3ef4">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1MultiIndexQuantizer2_1a553b9a33e9be7f231ffdc0ac53c59e7c">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPQFastScan_1ae8846519e0f1b9fedd5eed195df3776f">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1a370dc8afa7357850d9031585ec8e2291">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRaBitQ_1a6a8dab5dc77eaa55726a4d97dea9ea3d">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRaBitQFastScan_1ad5c03d0e4cdc6bc2f6e288c2b9255211">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRefine_1a759db97766dcfe29c162e3339d68bd7d">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRowwiseMinMaxFP16_1a1b5c007b0cb0f76960a073b9843d8ae5">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRowwiseMinMax_1a71ecee52a0e63061b9a96b2feb628bc9">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexScalarQuantizer_1a300647e9cdac9acd160f2c55c610056b">train</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexSplitVectors_1aafa4c780e325855fe247052453967845">train</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const float *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Perform training on a representative set of vectors</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>nb of training vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>training vecors, size n * d </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="130" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1af8f340497140cc8b091f4732c3460537" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::train_ex</definition>
        <argsstring>(idx_t n, const void *x, NumericType numeric_type)</argsstring>
        <name>train_ex</name>
        <qualifiedname>faiss::Index::train_ex</qualifiedname>
        <reimplementedby refid="structfaiss_1_1gpu_1_1GpuIndexCagra_1a8a472fd13dca61dd0da11b0db3486d29">train_ex</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>NumericType</type>
          <declname>numeric_type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="132" column="18" bodyfile="faiss/Index.h" bodystart="132" bodyend="138"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1aa432f349b82d0909c33aa353b7a01fe1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::add_ex</definition>
        <argsstring>(idx_t n, const void *x, NumericType numeric_type)</argsstring>
        <name>add_ex</name>
        <qualifiedname>faiss::Index::add_ex</qualifiedname>
        <reimplementedby refid="structfaiss_1_1gpu_1_1GpuIndexCagra_1ae6308a059e81139f55e67dfc709e6a6e">add_ex</reimplementedby>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndex_1afab6f6c4b430e672bad9bee8264cc6f4">add_ex</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>NumericType</type>
          <declname>numeric_type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="150" column="18" bodyfile="faiss/Index.h" bodystart="150" bodyend="156"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a13b30ab195baded94b6db98d8e111ed7" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::add_with_ids</definition>
        <argsstring>(idx_t n, const float *x, const idx_t *xids)</argsstring>
        <name>add_with_ids</name>
        <qualifiedname>faiss::Index::add_with_ids</qualifiedname>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndex_1a0e7fa779ba9d47b0af36161de2a3b191">add_with_ids</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1a14e75169bddcd0251134821416b060a1">add_with_ids</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFFastScan_1a8699e7d828750f02bfc86014269e4a6c">add_with_ids</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFFlatDedup_1a4e27cfca56590371e0984d8f16b2b68d">add_with_ids</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFPQR_1ae526b4722b470a33643d40ef30cf27f7">add_with_ids</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1aa37b7428e0ac315db5e52b1cb1e42605">add_with_ids</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const float *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref> *</type>
          <declname>xids</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Same as add, but stores xids instead of sequential ids.</para>
<para>The default implementation fails with an assertion, as it is not supported by all indexes.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>input vectors, size n * d </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>xids</parametername>
</parameternamelist>
<parameterdescription>
<para>if non-null, ids to store for the vectors (size n) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="167" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1ac306752b6e39ee77a97c2a0ac193b8c5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::add_with_ids_ex</definition>
        <argsstring>(idx_t n, const void *x, NumericType numeric_type, const idx_t *xids)</argsstring>
        <name>add_with_ids_ex</name>
        <qualifiedname>faiss::Index::add_with_ids_ex</qualifiedname>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndex_1aa4ee320c856211e4e6238b95eb338996">add_with_ids_ex</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>NumericType</type>
          <declname>numeric_type</declname>
        </param>
        <param>
          <type>const <ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref> *</type>
          <declname>xids</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="168" column="18" bodyfile="faiss/Index.h" bodystart="168" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a06690b86bad667d42a0387c7cd3359e9" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::search_ex</definition>
        <argsstring>(idx_t n, const void *x, NumericType numeric_type, idx_t k, float *distances, idx_t *labels, const SearchParameters *params=nullptr) const</argsstring>
        <name>search_ex</name>
        <qualifiedname>faiss::Index::search_ex</qualifiedname>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndex_1a5dbd8404a4bf32a43dbf9a349a680b9d">search_ex</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>NumericType</type>
          <declname>numeric_type</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>distances</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref> *</type>
          <declname>labels</declname>
        </param>
        <param>
          <type>const <ref refid="structfaiss_1_1SearchParameters" kindref="compound">SearchParameters</ref> *</type>
          <declname>params</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="199" column="18" bodyfile="faiss/Index.h" bodystart="199" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a5d69b1965b4cd9d11a57222dfc89b7ba" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::range_search</definition>
        <argsstring>(idx_t n, const float *x, float radius, RangeSearchResult *result, const SearchParameters *params=nullptr) const</argsstring>
        <name>range_search</name>
        <qualifiedname>faiss::Index::range_search</qualifiedname>
        <reimplementedby refid="structfaiss_1_1IndexFlat_1af3c56bae3b28baeb3e50aed74006a319">range_search</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlatCodes_1ac0874451b339054470272d4eea5d62ff">range_search</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexHNSW_1a1a8147a4071708c53967fde0dd294d4c">range_search</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1a3c9714bf7fb9a2268ac4f3a46c286151">range_search</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFFastScan_1a1f8213db15661df4339ec9ce4e2244a9">range_search</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFFlatDedup_1a4a3599498e1c2d548836cc049056609e">range_search</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1a5374e209bc7577e848577c1d21fb5260">range_search</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRaBitQ_1a97da3c2d6eeba361a5af60a6a07e62e9">range_search</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRefine_1a0b8e378d2a5f040f7c82e2ddcc1f27c0">range_search</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const float *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>float</type>
          <declname>radius</declname>
        </param>
        <param>
          <type><ref refid="structfaiss_1_1RangeSearchResult" kindref="compound">RangeSearchResult</ref> *</type>
          <declname>result</declname>
        </param>
        <param>
          <type>const <ref refid="structfaiss_1_1SearchParameters" kindref="compound">SearchParameters</ref> *</type>
          <declname>params</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>query n vectors of dimension d to the index.</para>
<para>return all vectors with distance &lt; radius. Note that many indexes do not implement the range_search (only the k-NN search is mandatory).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>input vectors to search, size n * d </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>radius</parametername>
</parameternamelist>
<parameterdescription>
<para>search radius </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>result</parametername>
</parameternamelist>
<parameterdescription>
<para>result table </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="230" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a010ae05c4ba70d309f9821d9b03182aa" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::assign</definition>
        <argsstring>(idx_t n, const float *x, idx_t *labels, idx_t k=1) const</argsstring>
        <name>assign</name>
        <qualifiedname>faiss::Index::assign</qualifiedname>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndex_1ab6382636bc3f651645ee66d8744f7c0f">assign</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const float *</type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref> *</type>
          <declname>labels</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>k</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>return the indexes of the k vectors closest to the query x.</para>
<para>This function is identical as search but only return labels of neighbors. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>input vectors to search, size n * d </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>labels</parametername>
</parameternamelist>
<parameterdescription>
<para>output labels of the NNs, size n*k </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k</parametername>
</parameternamelist>
<parameterdescription>
<para>number of nearest neighbours </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="246" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1ab70f7d0acb4a2f22857da3b17559ae82" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>size_t</type>
        <definition>virtual size_t faiss::Index::remove_ids</definition>
        <argsstring>(const IDSelector &amp;sel)</argsstring>
        <name>remove_ids</name>
        <qualifiedname>faiss::Index::remove_ids</qualifiedname>
        <reimplementedby refid="structfaiss_1_1IndexFastScan_1aff3bf1664f78f7a121f4f513e2f75af7">remove_ids</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlatCodes_1a6d033f2cbc377bb26948a5dfa6b5aa3c">remove_ids</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1a7f4d5e3d38ed2db026780522ffb85b9d">remove_ids</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFFlatDedup_1a528e3ac6d5b1c10954dfbdb6779d69bf">remove_ids</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFPQR_1aabe4bb3b249f15af977c954f36e81147">remove_ids</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1a5781db5439f1d0f06cb3bf4c71ac0563">remove_ids</reimplementedby>
        <param>
          <type>const <ref refid="structfaiss_1_1IDSelector" kindref="compound">IDSelector</ref> &amp;</type>
          <declname>sel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>removes IDs from the index. Not supported by all indexes. Returns the number of elements removed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="255" column="20"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1afaf9673009f9fe5a53ed6db522a5f69c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::reconstruct</definition>
        <argsstring>(idx_t key, float *recons) const</argsstring>
        <name>reconstruct</name>
        <qualifiedname>faiss::Index::reconstruct</qualifiedname>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndexFlat_1a43f3344a2855d2842873d868c192508b">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1AdditiveCoarseQuantizer_1a68a74f41ca7c511663dd573183fb670b">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFastScan_1a249e3ec94d8ca092d7aa1263c0e3fa67">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlat_1ae4b33315752b62cff1626f9f967167b1">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlatCodes_1afe96eb3293cc5428f9077648b23fcc4e">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexHNSW_1a660e5c8de1ba9c71bf3fe1f3bf0c8812">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1a3b3270dcfa248dc30117644382a54e39">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexNNDescent_1a1c6827189741d6d596421fae6475f4da">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexNSG_1a443fa9f9a866fca02ff55af0226ccb6a">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1MultiIndexQuantizer_1aa5bd578560419955a4bf7035cf09a392">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1afc92036fae3041caf6331b67754b599c">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRefine_1a01356d39a4eda730517a295c2c7bb869">reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRandom_1aeb61a0418e111af3a3409905cd6b6483">reconstruct</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>key</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>recons</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reconstruct a stored vector (or an approximation if lossy coding)</para>
<para>this function may not be defined for some indexes <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>key</parametername>
</parameternamelist>
<parameterdescription>
<para>id of the vector to reconstruct </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>recons</parametername>
</parameternamelist>
<parameterdescription>
<para>reconstucted vector (size d) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="263" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a1dbf5eac7d05ca6271d2fd9bee568218" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::reconstruct_batch</definition>
        <argsstring>(idx_t n, const idx_t *keys, float *recons) const</argsstring>
        <name>reconstruct_batch</name>
        <qualifiedname>faiss::Index::reconstruct_batch</qualifiedname>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndexFlat_1a66814ad5f94a9e7534d4fdf4951d9bee">reconstruct_batch</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const <ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref> *</type>
          <declname>keys</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>recons</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reconstruct several stored vectors (or an approximation if lossy coding)</para>
<para>this function may not be defined for some indexes <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of vectors to reconstruct </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>keys</parametername>
</parameternamelist>
<parameterdescription>
<para>ids of the vectors to reconstruct (size n) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>recons</parametername>
</parameternamelist>
<parameterdescription>
<para>reconstucted vector (size n * d) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="273" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1ae7c0b683e1fd5c8770ea2b3e1a82ce7f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::reconstruct_n</definition>
        <argsstring>(idx_t i0, idx_t ni, float *recons) const</argsstring>
        <name>reconstruct_n</name>
        <qualifiedname>faiss::Index::reconstruct_n</qualifiedname>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndexIVFFlat_1ab95cbd3b7e87771c72c1e166a9caef2a">reconstruct_n</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlatCodes_1a166582b8b10fc86e77ce8c48854496f8">reconstruct_n</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1a7cc286dfbd8bfd43ea4b22173e28231c">reconstruct_n</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1a02ebb27dd56aec9a93c50bd6b96184e7">reconstruct_n</reimplementedby>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndexFlat_1a877b903b95d7b0d2bc48717a1690b6da">reconstruct_n</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>i0</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>ni</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>recons</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reconstruct vectors i0 to i0 + ni - 1</para>
<para>this function may not be defined for some indexes <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>i0</parametername>
</parameternamelist>
<parameterdescription>
<para>index of the first vector in the sequence </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ni</parametername>
</parameternamelist>
<parameterdescription>
<para>number of vectors in the sequence </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>recons</parametername>
</parameternamelist>
<parameterdescription>
<para>reconstucted vector (size ni * d) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="283" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1aed4bdbec95c0c3583e139f8e268ea0a6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::search_and_reconstruct</definition>
        <argsstring>(idx_t n, const float *x, idx_t k, float *distances, idx_t *labels, float *recons, const SearchParameters *params=nullptr) const</argsstring>
        <name>search_and_reconstruct</name>
        <qualifiedname>faiss::Index::search_and_reconstruct</qualifiedname>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndex_1a6d03010928f0a641ac6a1b45c0c034f0">search_and_reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1ae370aa40139ca15359b1cbdf88c9b3d8">search_and_reconstruct</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1a6082f6ca04afc943d5e1c729f24de283">search_and_reconstruct</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const float *</type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>distances</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref> *</type>
          <declname>labels</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>recons</declname>
        </param>
        <param>
          <type>const <ref refid="structfaiss_1_1SearchParameters" kindref="compound">SearchParameters</ref> *</type>
          <declname>params</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Similar to search, but also reconstructs the stored vectors (or an approximation in the case of lossy coding) for the search results.</para>
<para>If there are not enough results for a query, the resulting arrays is padded with -1s.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>input vectors to search, size n * d </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k</parametername>
</parameternamelist>
<parameterdescription>
<para>number of extracted vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>distances</parametername>
</parameternamelist>
<parameterdescription>
<para>output pairwise distances, size n*k </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>labels</parametername>
</parameternamelist>
<parameterdescription>
<para>output labels of the NNs, size n*k </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>recons</parametername>
</parameternamelist>
<parameterdescription>
<para>reconstructed vectors size (n, k, d) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="298" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a1f12e2118b37a511f51d63e1aa9c0c20" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::compute_residual</definition>
        <argsstring>(const float *x, float *residual, idx_t key) const</argsstring>
        <name>compute_residual</name>
        <qualifiedname>faiss::Index::compute_residual</qualifiedname>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndex_1ae076ddbcfde3e7a21879ac379ff991d9">compute_residual</reimplementedby>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndexFlat_1af7f8f3b84c0894ffb072dbc32f9e6787">compute_residual</reimplementedby>
        <param>
          <type>const float *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>residual</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Computes a residual vector after indexing encoding.</para>
<para>The residual vector is the difference between a vector and the reconstruction that can be decoded from its representation in the index. The residual can be used for multiple-stage indexing methods, like <ref refid="structfaiss_1_1IndexIVF" kindref="compound">IndexIVF</ref>&apos;s methods.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>input vector, size d </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>residual</parametername>
</parameternamelist>
<parameterdescription>
<para>output residual vector, size d </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>key</parametername>
</parameternamelist>
<parameterdescription>
<para>encoded index, as returned by search and assign </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="318" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1aff98fbf8e7dadf9ff528a031c53a43fa" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::compute_residual_n</definition>
        <argsstring>(idx_t n, const float *xs, float *residuals, const idx_t *keys) const</argsstring>
        <name>compute_residual_n</name>
        <qualifiedname>faiss::Index::compute_residual_n</qualifiedname>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndex_1a1a1ccf88e127b613c5ef65e52d7a6428">compute_residual_n</reimplementedby>
        <reimplementedby refid="classfaiss_1_1gpu_1_1GpuIndexFlat_1a8dddfaa491c1c2cfe2e03fa06e9676b4">compute_residual_n</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const float *</type>
          <declname>xs</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>residuals</declname>
        </param>
        <param>
          <type>const <ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref> *</type>
          <declname>keys</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Computes a residual vector after indexing encoding (batch form). Equivalent to calling compute_residual for each vector.</para>
<para>The residual vector is the difference between a vector and the reconstruction that can be decoded from its representation in the index. The residual can be used for multiple-stage indexing methods, like <ref refid="structfaiss_1_1IndexIVF" kindref="compound">IndexIVF</ref>&apos;s methods.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>xs</parametername>
</parameternamelist>
<parameterdescription>
<para>input vectors, size (n x d) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>residuals</parametername>
</parameternamelist>
<parameterdescription>
<para>output residual vectors, size (n x d) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>keys</parametername>
</parameternamelist>
<parameterdescription>
<para>encoded index, as returned by search and assign </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="334" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a5d7e4b432ee751157d470256a7fe8afc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="structfaiss_1_1DistanceComputer" kindref="compound">DistanceComputer</ref> *</type>
        <definition>virtual DistanceComputer * faiss::Index::get_distance_computer</definition>
        <argsstring>() const</argsstring>
        <name>get_distance_computer</name>
        <qualifiedname>faiss::Index::get_distance_computer</qualifiedname>
        <reimplementedby refid="structfaiss_1_1Index2Layer_1ae148c7b7ab50a2d3859002b64572cb0f">get_distance_computer</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlatCodes_1ad1f46f8661b11c413c4ba66d842f35ed">get_distance_computer</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexHNSW_1af1f0080b012492ffcab261eaa25b1545">get_distance_computer</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFRaBitQ_1ad3bf565bb0446e201db587c39b84176f">get_distance_computer</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1a4e0180e2aa2aacaa2532660bdb4f9b8c">get_distance_computer</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get a <ref refid="structfaiss_1_1DistanceComputer" kindref="compound">DistanceComputer</ref> (defined in AuxIndexStructures) object for this kind of index.</para>
<para><ref refid="structfaiss_1_1DistanceComputer" kindref="compound">DistanceComputer</ref> is implemented for indexes that support random access of their vectors. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="346" column="30"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a5a050b805d4836afdf8f09251ad8b415" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>size_t</type>
        <definition>virtual size_t faiss::Index::sa_code_size</definition>
        <argsstring>() const</argsstring>
        <name>sa_code_size</name>
        <qualifiedname>faiss::Index::sa_code_size</qualifiedname>
        <reimplementedby refid="structfaiss_1_1IndexFastScan_1a177e8f06f3ac7a6cc90cd0b817b97e58">sa_code_size</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlatCodes_1a7252bbbd4059cb1ea4b43e52eadc920a">sa_code_size</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1a89b7f3a7b35db764bc071aa5ab302b1d">sa_code_size</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexLattice_1ac7c27786912bed039ef8d05a82db0acb">sa_code_size</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1ad803358238737eda7f185b486e6081fe">sa_code_size</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRefine_1a4f4fa1a53bd9603ea000e556cbd6940f">sa_code_size</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRowwiseMinMaxFP16_1a4fa54c45e907f5bb75b7c3dd46a24b9a">sa_code_size</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRowwiseMinMax_1a656e29f7f050b80cde5ca7e8b56eb960">sa_code_size</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>size of the produced codes in bytes </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="351" column="20"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a16770c0addc888b92deee089d6f97e7c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::sa_encode</definition>
        <argsstring>(idx_t n, const float *x, uint8_t *bytes) const</argsstring>
        <name>sa_encode</name>
        <qualifiedname>faiss::Index::sa_encode</qualifiedname>
        <reimplementedby refid="structfaiss_1_1Index2Layer_1a205db18d83af2fc98faab3f0066e8c9f">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexAdditiveQuantizer_1a32fa884e35be46b3244b90012bdcc016">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFastScan_1a57ce48e11490ead0689aee9df3a502be">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlat_1aaa95cb6086e2889e1c3f4478e454bc67">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1a9d28b314ee008589eb41ce2823a088b6">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexLattice_1abbe02fd8270a854f7b25285d9a0a5752">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexLSH_1aac0eb8b22431e490a28fdc566a461af5">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPQ_1a438591a838aad52cd69e021c7b93110f">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1a5fc4aff1479e447435e1f08b2a88d1d6">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRaBitQ_1afbcc303ffecc074f1665af171f692054">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRefine_1a8f7cc71fbded7eaf35bcccf41603085d">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRowwiseMinMaxFP16_1a7f4963d9ea750a494151478fc56df10a">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRowwiseMinMax_1ab2dfc5e5adcbfa9fcf5ecd30ddd407a8">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexScalarQuantizer_1ae8c5ed4f9c2145aa074986bf1be3af46">sa_encode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexNeuralNetCodec_1a90a9e0e680a9734bf24b029e4218a43c">sa_encode</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const float *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>uint8_t *</type>
          <declname>bytes</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>encode a set of vectors</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>input vectors, size n * d </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>output encoded vectors, size n * <ref refid="structfaiss_1_1Index_1a5a050b805d4836afdf8f09251ad8b415" kindref="member">sa_code_size()</ref> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="359" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1af39e4b00d097ac05dc9e31c52bfb9ed7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::sa_decode</definition>
        <argsstring>(idx_t n, const uint8_t *bytes, float *x) const</argsstring>
        <name>sa_decode</name>
        <qualifiedname>faiss::Index::sa_decode</qualifiedname>
        <reimplementedby refid="structfaiss_1_1Index2Layer_1aefba1e901bddaa812e853a8203b2f0b5">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexAdditiveQuantizer_1af849220ce067392a737dcbca233326ad">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexAdditiveQuantizerFastScan_1a3b295457588bd7f11782f84683eaff8d">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlat_1af84e108340092e5d3970ab8824a71658">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFFastScan_1a0f23ffc33cf0de396080f9c07888f9ca">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFFlat_1a1464960b17488f8ee8ae600c07f7b72c">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFPQ_1adb7494c07ce7812226ad41c8b6dca992">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFRaBitQ_1a79ceddd914b81c8fa67c6d27e4a3dc12">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexLattice_1a3fd27c778f435412336110785ba7124d">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexLSH_1ac1eaeea883e641e50c5b770fb02edc25">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPQ_1a104104a52149ebdcb8ab79dc01180b6e">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPQFastScan_1afe1ce4711953b8a679f83210fee8a30b">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1a544759849772119156adf601287e50b0">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRaBitQ_1a65ebc38abdff6a6fd9df63fecc775fa9">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRaBitQFastScan_1ac182edfc908e98ee0603c6725dd24e74">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRefine_1acff97ef10e27f43dc72f5faa21c67a4e">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRowwiseMinMaxFP16_1a9844bbc4ea9311674b0921108988222d">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexRowwiseMinMax_1ab04e9ffc561f4de77af64d9ab122d58f">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexScalarQuantizer_1a96a5ca50fbdef07c7773bb9a27e860e5">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFScalarQuantizer_1ae10ad1a5c025337984277a68f4da4338">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFAdditiveQuantizer_1a0ce87a96183a3bbd1b3d70b6fe7e30ce">sa_decode</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexNeuralNetCodec_1a959a2734dcc70267ac5b900fbe0d7825">sa_decode</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const uint8_t *</type>
          <declname>bytes</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>decode a set of vectors</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>input encoded vectors, size n * <ref refid="structfaiss_1_1Index_1a5a050b805d4836afdf8f09251ad8b415" kindref="member">sa_code_size()</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>output vectors, size n * d </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="367" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a989b8815705e95d61adcb87380660415" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::merge_from</definition>
        <argsstring>(Index &amp;otherIndex, idx_t add_id=0)</argsstring>
        <name>merge_from</name>
        <qualifiedname>faiss::Index::merge_from</qualifiedname>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1a058974c6ac51dbe788fcc1fe004add7e">merge_from</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVFPQR_1a9bca412954ab2ead5bc4f71ee8743e1e">merge_from</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFastScan_1af0e22783a659894065a86e8a60ce7bf8">merge_from</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlatCodes_1a3648a16e47f5f9567c50ad4fd49453ca">merge_from</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1ae3af026662cdce35dbce0b73acf09ab7">merge_from</reimplementedby>
        <param>
          <type><ref refid="structfaiss_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>otherIndex</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>add_id</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>moves the entries from another dataset to self. On output, other is empty. add_id is added to all moved ids (for sequential ids, this would be this-&gt;ntotal) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="373" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1a87b6300674be1e0a48210da998fb796e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::check_compatible_for_merge</definition>
        <argsstring>(const Index &amp;otherIndex) const</argsstring>
        <name>check_compatible_for_merge</name>
        <qualifiedname>faiss::Index::check_compatible_for_merge</qualifiedname>
        <reimplementedby refid="structfaiss_1_1IndexFastScan_1aff0a176ed14d8d64ca7b0ad1f3ebcbdf">check_compatible_for_merge</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlatCodes_1a3ec1c75f8caa2ac5e59cfbb62efb910a">check_compatible_for_merge</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1a5a097e5b50f8b220db61b52c6fdaf1f9">check_compatible_for_merge</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexPreTransform_1a882647c37d7b8eb55a5d494538283536">check_compatible_for_merge</reimplementedby>
        <param>
          <type>const <ref refid="structfaiss_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>otherIndex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>check that the two indexes are compatible (ie, they are trained in the same way and have the same parameters). Otherwise throw. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="378" column="18"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1Index_1aaaec1fac2c4ef7bf6e2b180fe4efbe6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::Index::add_sa_codes</definition>
        <argsstring>(idx_t n, const uint8_t *codes, const idx_t *xids)</argsstring>
        <name>add_sa_codes</name>
        <qualifiedname>faiss::Index::add_sa_codes</qualifiedname>
        <reimplementedby refid="structfaiss_1_1IndexIVF_1a23981fa9b4a027d8a43da073d9d2c685">add_sa_codes</reimplementedby>
        <reimplementedby refid="structfaiss_1_1IndexFlatCodes_1ad30841b719b3c4949f0ac5f656e28ee2">add_sa_codes</reimplementedby>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const uint8_t *</type>
          <declname>codes</declname>
        </param>
        <param>
          <type>const <ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref> *</type>
          <declname>xids</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add vectors that are computed with the standalone codec</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>codes</parametername>
</parameternamelist>
<parameterdescription>
<para>codes to add size n * <ref refid="structfaiss_1_1Index_1a5a050b805d4836afdf8f09251ad8b415" kindref="member">sa_code_size()</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>xids</parametername>
</parameternamelist>
<parameterdescription>
<para>corresponding ids, size n </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="385" column="18"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="structfaiss_1_1Index_1af317cb1e2ad0bd145f716f2243b693eb" prot="public" static="no">
        <type>float</type>
        <definition>using faiss::Index::component_t =  float</definition>
        <argsstring></argsstring>
        <name>component_t</name>
        <qualifiedname>faiss::Index::component_t</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="100" column="5" bodyfile="faiss/Index.h" bodystart="100" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="structfaiss_1_1Index_1a1c60d7a12bf3ad27054963df8cccd93f" prot="public" static="no">
        <type>float</type>
        <definition>using faiss::Index::distance_t =  float</definition>
        <argsstring></argsstring>
        <name>distance_t</name>
        <qualifiedname>faiss::Index::distance_t</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/Index.h" line="101" column="5" bodyfile="faiss/Index.h" bodystart="101" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Provides base functions for rowwise normalizing indices. </para>
    </briefdescription>
    <detaileddescription>
<para><ref refid="structfaiss_1_1Index" kindref="compound">Index</ref> wrapper that performs rowwise normalization to [0,1], preserving the coefficients. This is a vector codec index only.</para>
<para>Basically, this index performs a rowwise scaling to [0,1] of every row in an input dataset before calling subindex::train() and subindex::sa_encode(). <ref refid="structfaiss_1_1Index_1a16770c0addc888b92deee089d6f97e7c" kindref="member">sa_encode()</ref> call stores the scaling coefficients (scaler and minv) in the very beginning of every output code. The format: [scaler][minv][subindex::sa_encode() output] The de-scaling in <ref refid="structfaiss_1_1Index_1af39e4b00d097ac05dc9e31c52bfb9ed7" kindref="member">sa_decode()</ref> is done using: output_rescaled = scaler * output + minv</para>
<para>An additional train_inplace() function is provided in order to do an inplace scaling before calling subindex::train() and, thus, avoiding the cloning of the input dataset, but modifying the input dataset because of the scaling and the scaling back. It is up to user to call this function instead of <ref refid="structfaiss_1_1Index_1a8f67dfd73993e192dc78f2c93d9d9532" kindref="member">train()</ref></para>
<para>Derived classes provide different data types for scaling coefficients. Currently, versions with fp16 and fp32 scaling coefficients are available.<itemizedlist>
<listitem><para>fp16 version adds 4 extra bytes per encoded vector</para>
</listitem><listitem><para>fp32 version adds 8 extra bytes per encoded vector </para>
</listitem></itemizedlist>
</para>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>faiss::Index</label>
        <link refid="structfaiss_1_1Index"/>
      </node>
      <node id="3">
        <label>faiss::IndexRowwiseMinMax</label>
        <link refid="structfaiss_1_1IndexRowwiseMinMax"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>faiss::IndexRowwiseMinMaxBase</label>
        <link refid="structfaiss_1_1IndexRowwiseMinMaxBase"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>faiss::IndexRowwiseMinMaxFP16</label>
        <link refid="structfaiss_1_1IndexRowwiseMinMaxFP16"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="2">
        <label>faiss::Index</label>
        <link refid="structfaiss_1_1Index"/>
      </node>
      <node id="1">
        <label>faiss::IndexRowwiseMinMaxBase</label>
        <link refid="structfaiss_1_1IndexRowwiseMinMaxBase"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="2" relation="usage">
          <edgelabel>index</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="faiss/IndexRowwiseMinMax.h" line="41" column="1" bodyfile="faiss/IndexRowwiseMinMax.h" bodystart="41" bodyend="65"/>
    <listofallmembers>
      <member refid="structfaiss_1_1IndexRowwiseMinMaxBase_1a2c727d28e4d8dc5eedfbea69695cf323" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>add</name></member>
      <member refid="structfaiss_1_1Index_1aa432f349b82d0909c33aa353b7a01fe1" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>add_ex</name></member>
      <member refid="structfaiss_1_1Index_1aaaec1fac2c4ef7bf6e2b180fe4efbe6b" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>add_sa_codes</name></member>
      <member refid="structfaiss_1_1Index_1a13b30ab195baded94b6db98d8e111ed7" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>add_with_ids</name></member>
      <member refid="structfaiss_1_1Index_1ac306752b6e39ee77a97c2a0ac193b8c5" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>add_with_ids_ex</name></member>
      <member refid="structfaiss_1_1Index_1a010ae05c4ba70d309f9821d9b03182aa" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>assign</name></member>
      <member refid="structfaiss_1_1Index_1a87b6300674be1e0a48210da998fb796e" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>check_compatible_for_merge</name></member>
      <member refid="structfaiss_1_1Index_1af317cb1e2ad0bd145f716f2243b693eb" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>component_t</name></member>
      <member refid="structfaiss_1_1Index_1a1f12e2118b37a511f51d63e1aa9c0c20" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>compute_residual</name></member>
      <member refid="structfaiss_1_1Index_1aff98fbf8e7dadf9ff528a031c53a43fa" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>compute_residual_n</name></member>
      <member refid="structfaiss_1_1Index_1a2a002388d2c081c2dbab8508dcefe73d" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>d</name></member>
      <member refid="structfaiss_1_1Index_1a1c60d7a12bf3ad27054963df8cccd93f" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>distance_t</name></member>
      <member refid="structfaiss_1_1Index_1a5d7e4b432ee751157d470256a7fe8afc" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>get_distance_computer</name></member>
      <member refid="structfaiss_1_1IndexRowwiseMinMaxBase_1a6def68df271f8809c1ed2cfa3107f082" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>index</name></member>
      <member refid="structfaiss_1_1Index_1a7b8cc435b5619d5d8382010a424bf67e" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>Index</name></member>
      <member refid="structfaiss_1_1IndexRowwiseMinMaxBase_1add65ec81582758713652b40bef00b024" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>IndexRowwiseMinMaxBase</name></member>
      <member refid="structfaiss_1_1IndexRowwiseMinMaxBase_1a4f20ffb075b81b0bee2f74b6aea0773b" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>IndexRowwiseMinMaxBase</name></member>
      <member refid="structfaiss_1_1Index_1a6e92732617c4dbe364e7678dd8773a7f" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>is_trained</name></member>
      <member refid="structfaiss_1_1Index_1a989b8815705e95d61adcb87380660415" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>merge_from</name></member>
      <member refid="structfaiss_1_1Index_1a6f60646d6877658ea4df05e0231ed232" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>metric_arg</name></member>
      <member refid="structfaiss_1_1Index_1a8e18f641854b2bde83ecff0a2f9a6f4e" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>metric_type</name></member>
      <member refid="structfaiss_1_1Index_1a6970683faa021b7a6f1a0865c0d4eccd" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>ntotal</name></member>
      <member refid="structfaiss_1_1IndexRowwiseMinMaxBase_1accffd820463f8e8021de397974d8daba" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>own_fields</name></member>
      <member refid="structfaiss_1_1Index_1a5d69b1965b4cd9d11a57222dfc89b7ba" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>range_search</name></member>
      <member refid="structfaiss_1_1Index_1afaf9673009f9fe5a53ed6db522a5f69c" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>reconstruct</name></member>
      <member refid="structfaiss_1_1Index_1a1dbf5eac7d05ca6271d2fd9bee568218" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>reconstruct_batch</name></member>
      <member refid="structfaiss_1_1Index_1ae7c0b683e1fd5c8770ea2b3e1a82ce7f" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>reconstruct_n</name></member>
      <member refid="structfaiss_1_1Index_1ab70f7d0acb4a2f22857da3b17559ae82" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>remove_ids</name></member>
      <member refid="structfaiss_1_1IndexRowwiseMinMaxBase_1ae2ae0c124b00ce684b6f2195061102f5" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>reset</name></member>
      <member refid="structfaiss_1_1Index_1a5a050b805d4836afdf8f09251ad8b415" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>sa_code_size</name></member>
      <member refid="structfaiss_1_1Index_1af39e4b00d097ac05dc9e31c52bfb9ed7" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>sa_decode</name></member>
      <member refid="structfaiss_1_1Index_1a16770c0addc888b92deee089d6f97e7c" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>sa_encode</name></member>
      <member refid="structfaiss_1_1IndexRowwiseMinMaxBase_1a4f41c5ae635cb0980607c9428a388879" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>search</name></member>
      <member refid="structfaiss_1_1Index_1aed4bdbec95c0c3583e139f8e268ea0a6" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>search_and_reconstruct</name></member>
      <member refid="structfaiss_1_1Index_1a06690b86bad667d42a0387c7cd3359e9" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>search_ex</name></member>
      <member refid="structfaiss_1_1Index_1a8f67dfd73993e192dc78f2c93d9d9532" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>train</name></member>
      <member refid="structfaiss_1_1Index_1af8f340497140cc8b091f4732c3460537" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>train_ex</name></member>
      <member refid="structfaiss_1_1IndexRowwiseMinMaxBase_1a594aec2b7bf912824b6d1559ecf85c34" prot="public" virt="pure-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>train_inplace</name></member>
      <member refid="structfaiss_1_1Index_1a5590d847c5c2b958affd2a05e58a6f23" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>verbose</name></member>
      <member refid="structfaiss_1_1Index_1a5fa7dbbb77a2a5c69b444672d2f1b982" prot="public" virt="virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>~Index</name></member>
      <member refid="structfaiss_1_1IndexRowwiseMinMaxBase_1a6a5b2154c5736881a4ee75b7b6488b2a" prot="public" virt="non-virtual"><scope>faiss::IndexRowwiseMinMaxBase</scope><name>~IndexRowwiseMinMaxBase</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
