<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="structfaiss_1_1IndexShardsTemplate" kind="struct" language="C++" prot="public">
    <compoundname>faiss::IndexShardsTemplate</compoundname>
    <basecompoundref refid="classfaiss_1_1ThreadedIndex" prot="public" virt="non-virtual">faiss::ThreadedIndex&lt; IndexT &gt;</basecompoundref>
    <derivedcompoundref refid="structfaiss_1_1IndexShardsIVF" prot="public" virt="non-virtual">faiss::IndexShardsIVF</derivedcompoundref>
    <includes refid="IndexShards_8h" local="no">IndexShards.h</includes>
    <templateparamlist>
      <param>
        <type>typename IndexT</type>
      </param>
    </templateparamlist>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="structfaiss_1_1IndexShardsTemplate_1ada31784dde1b51d8be8b15288943c559" prot="public" static="no">
        <type>typename IndexT::component_t</type>
        <definition>using faiss::IndexShardsTemplate&lt; IndexT &gt;::component_t =  typename IndexT::component_t</definition>
        <argsstring></argsstring>
        <name>component_t</name>
        <qualifiedname>faiss::IndexShardsTemplate::component_t</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="21" column="5" bodyfile="faiss/IndexShards.h" bodystart="21" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="structfaiss_1_1IndexShardsTemplate_1a94570791e9f70d2bef77d76564571417" prot="public" static="no">
        <type>typename IndexT::distance_t</type>
        <definition>using faiss::IndexShardsTemplate&lt; IndexT &gt;::distance_t =  typename IndexT::distance_t</definition>
        <argsstring></argsstring>
        <name>distance_t</name>
        <qualifiedname>faiss::IndexShardsTemplate::distance_t</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="22" column="5" bodyfile="faiss/IndexShards.h" bodystart="22" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="structfaiss_1_1IndexShardsTemplate_1aa79db16c723ae37eaf406e840e4f227a" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool faiss::IndexShardsTemplate&lt; IndexT &gt;::successive_ids</definition>
        <argsstring></argsstring>
        <name>successive_ids</name>
        <qualifiedname>faiss::IndexShardsTemplate::successive_ids</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="94" column="10" bodyfile="faiss/IndexShards.h" bodystart="94" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classfaiss_1_1ThreadedIndex_1a1223180acd3979e7205c91d2dba9d306" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool faiss::ThreadedIndex&lt; IndexT &gt;::own_indices</definition>
        <argsstring></argsstring>
        <name>own_indices</name>
        <qualifiedname>faiss::ThreadedIndex::own_indices</qualifiedname>
        <initializer>= false</initializer>
        <briefdescription>
<para>Whether or not we are responsible for deleting our contained indices. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="65" column="10" bodyfile="faiss/impl/ThreadedIndex.h" bodystart="65" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1a2ffc0edbce1815fae55cae188b83a5cf" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>faiss::IndexShardsTemplate&lt; IndexT &gt;::IndexShardsTemplate</definition>
        <argsstring>(bool threaded=false, bool successive_ids=true)</argsstring>
        <name>IndexShardsTemplate</name>
        <qualifiedname>faiss::IndexShardsTemplate::IndexShardsTemplate</qualifiedname>
        <param>
          <type>bool</type>
          <declname>threaded</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>successive_ids</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The dimension that all sub-indices must share will be the dimension of the first sub-index added</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>threaded</parametername>
</parameternamelist>
<parameterdescription>
<para>do we use one thread per sub_index or do queries sequentially? </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>successive_ids</parametername>
</parameternamelist>
<parameterdescription>
<para>should we shift the returned ids by the size of each sub-index or return them as they are? </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="34" column="14"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1ac278d8f7d54923cb034127a4257c56b7" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>faiss::IndexShardsTemplate&lt; IndexT &gt;::IndexShardsTemplate</definition>
        <argsstring>(idx_t d, bool threaded=false, bool successive_ids=true)</argsstring>
        <name>IndexShardsTemplate</name>
        <qualifiedname>faiss::IndexShardsTemplate::IndexShardsTemplate</qualifiedname>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>d</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>threaded</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>successive_ids</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>threaded</parametername>
</parameternamelist>
<parameterdescription>
<para>do we use one thread per sub_index or do queries sequentially? </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>successive_ids</parametername>
</parameternamelist>
<parameterdescription>
<para>should we shift the returned ids by the size of each sub-index or return them as they are? </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="45" column="14"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1a0596f5ca67d6c9bfddae1465c5353b29" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>faiss::IndexShardsTemplate&lt; IndexT &gt;::IndexShardsTemplate</definition>
        <argsstring>(int d, bool threaded=false, bool successive_ids=true)</argsstring>
        <name>IndexShardsTemplate</name>
        <qualifiedname>faiss::IndexShardsTemplate::IndexShardsTemplate</qualifiedname>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>threaded</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>successive_ids</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>int version due to the implicit bool conversion ambiguity of int as dimension </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="52" column="14"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1a47a2e1f78d91025857f483be3eb6828a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void faiss::IndexShardsTemplate&lt; IndexT &gt;::add_shard</definition>
        <argsstring>(IndexT *index)</argsstring>
        <name>add_shard</name>
        <qualifiedname>faiss::IndexShardsTemplate::add_shard</qualifiedname>
        <param>
          <type>IndexT *</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Alias for <ref refid="classfaiss_1_1ThreadedIndex_1a9a11a672369d48f45cf1dd1bfe0dad87" kindref="member">addIndex()</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="58" column="10" bodyfile="faiss/IndexShards.h" bodystart="58" bodyend="60"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1ae0bff98885fecae6c42a474d05563ecd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void faiss::IndexShardsTemplate&lt; IndexT &gt;::remove_shard</definition>
        <argsstring>(IndexT *index)</argsstring>
        <name>remove_shard</name>
        <qualifiedname>faiss::IndexShardsTemplate::remove_shard</qualifiedname>
        <param>
          <type>IndexT *</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Alias for <ref refid="classfaiss_1_1ThreadedIndex_1a21604d6b8b8d42e6cc78c26e85564027" kindref="member">removeIndex()</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="63" column="10" bodyfile="faiss/IndexShards.h" bodystart="63" bodyend="65"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1a45647579ff21e0945d8a87a97ec705fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void faiss::IndexShardsTemplate&lt; IndexT &gt;::add</definition>
        <argsstring>(idx_t n, const component_t *x) override</argsstring>
        <name>add</name>
        <qualifiedname>faiss::IndexShardsTemplate::add</qualifiedname>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const component_t *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>supported only for sub-indices that implement add_with_ids </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="68" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1a15e0b4a2fd85f9345537d215a331ed91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void faiss::IndexShardsTemplate&lt; IndexT &gt;::add_with_ids</definition>
        <argsstring>(idx_t n, const component_t *x, const idx_t *xids) override</argsstring>
        <name>add_with_ids</name>
        <qualifiedname>faiss::IndexShardsTemplate::add_with_ids</qualifiedname>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const component_t *</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref> *</type>
          <declname>xids</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Cases (successive_ids, xids):<itemizedlist>
<listitem><para>true, non-NULL ERROR: it makes no sense to pass in ids and request them to be shifted</para>
</listitem><listitem><para>true, NULL OK: but should be called only once (calls <ref refid="structfaiss_1_1IndexShardsTemplate_1a45647579ff21e0945d8a87a97ec705fe" kindref="member">add()</ref> on sub-indexes).</para>
</listitem><listitem><para>false, non-NULL OK: will call add_with_ids with passed in xids distributed evenly over shards</para>
</listitem><listitem><para>false, NULL OK: will call add_with_ids on each sub-index, starting at ntotal </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="81" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1ad8c210aad3ef56b82cc5ea47105095f7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void faiss::IndexShardsTemplate&lt; IndexT &gt;::search</definition>
        <argsstring>(idx_t n, const component_t *x, idx_t k, distance_t *distances, idx_t *labels, const SearchParameters *params=nullptr) const override</argsstring>
        <name>search</name>
        <qualifiedname>faiss::IndexShardsTemplate::search</qualifiedname>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const component_t *</type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>distance_t *</type>
          <declname>distances</declname>
        </param>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref> *</type>
          <declname>labels</declname>
        </param>
        <param>
          <type>const <ref refid="structfaiss_1_1SearchParameters" kindref="compound">SearchParameters</ref> *</type>
          <declname>params</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="84" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1aa7d268a8a30e16f52e192d41a57b8626" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void faiss::IndexShardsTemplate&lt; IndexT &gt;::train</definition>
        <argsstring>(idx_t n, const component_t *x) override</argsstring>
        <name>train</name>
        <qualifiedname>faiss::IndexShardsTemplate::train</qualifiedname>
        <param>
          <type><ref refid="namespacefaiss_1ad63e84aa82f5bb0405ed924d58b20e2e" kindref="member">idx_t</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type>const component_t *</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="92" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1aaf3c7b44b9f30f17f58aded129eeff58" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void faiss::IndexShardsTemplate&lt; IndexT &gt;::syncWithSubIndexes</definition>
        <argsstring>()</argsstring>
        <name>syncWithSubIndexes</name>
        <qualifiedname>faiss::IndexShardsTemplate::syncWithSubIndexes</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Synchronize the top-level index (IndexShards) with data in the sub-indices </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="98" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classfaiss_1_1ThreadedIndex_1a9a11a672369d48f45cf1dd1bfe0dad87" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void faiss::ThreadedIndex&lt; IndexT &gt;::addIndex</definition>
        <argsstring>(IndexT *index)</argsstring>
        <name>addIndex</name>
        <qualifiedname>faiss::ThreadedIndex::addIndex</qualifiedname>
        <param>
          <type>IndexT *</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>override an index that is managed by ourselves. WARNING: once an index is added, it becomes unsafe to touch it from any other thread than that on which is managing it, until we are shut down. Use runOnIndex to perform work on it instead. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="32" column="18" bodyfile="faiss/impl/ThreadedIndex-inl.h" bodystart="45" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="classfaiss_1_1ThreadedIndex_1a21604d6b8b8d42e6cc78c26e85564027" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void faiss::ThreadedIndex&lt; IndexT &gt;::removeIndex</definition>
        <argsstring>(IndexT *index)</argsstring>
        <name>removeIndex</name>
        <qualifiedname>faiss::ThreadedIndex::removeIndex</qualifiedname>
        <param>
          <type>IndexT *</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Remove an index that is managed by ourselves. This will flush all pending work on that index, and then shut down its managing thread, and will remove the index. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="37" column="10" bodyfile="faiss/impl/ThreadedIndex-inl.h" bodystart="87" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="classfaiss_1_1ThreadedIndex_1a30ade89dc4e571868cf121e5592d6687" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void faiss::ThreadedIndex&lt; IndexT &gt;::runOnIndex</definition>
        <argsstring>(std::function&lt; void(int, IndexT *)&gt; f)</argsstring>
        <name>runOnIndex</name>
        <qualifiedname>faiss::ThreadedIndex::runOnIndex</qualifiedname>
        <param>
          <type>std::function&lt; void(int, IndexT *)&gt;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Run a function on all indices, in the thread that the index is managed in. Function arguments are (index in collection, index pointer) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="42" column="10" bodyfile="faiss/impl/ThreadedIndex-inl.h" bodystart="118" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="classfaiss_1_1ThreadedIndex_1af5188782bc9e776800b96d1610b3f22b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void faiss::ThreadedIndex&lt; IndexT &gt;::runOnIndex</definition>
        <argsstring>(std::function&lt; void(int, const IndexT *)&gt; f) const</argsstring>
        <name>runOnIndex</name>
        <qualifiedname>faiss::ThreadedIndex::runOnIndex</qualifiedname>
        <param>
          <type>std::function&lt; void(int, const IndexT *)&gt;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="43" column="10" bodyfile="faiss/impl/ThreadedIndex-inl.h" bodystart="150" bodyend="154"/>
      </memberdef>
      <memberdef kind="function" id="classfaiss_1_1ThreadedIndex_1a4536f6e7a8cce1f79bebc420ae1e909b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void faiss::ThreadedIndex&lt; IndexT &gt;::reset</definition>
        <argsstring>() override</argsstring>
        <name>reset</name>
        <qualifiedname>faiss::ThreadedIndex::reset</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="structfaiss_1_1Index" kindref="compound">faiss::Index</ref> API All indices receive the same call </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="47" column="10" bodyfile="faiss/impl/ThreadedIndex-inl.h" bodystart="157" bodyend="161"/>
      </memberdef>
      <memberdef kind="function" id="classfaiss_1_1ThreadedIndex_1a2f9cadbcb9335c0833f61259230429a7" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int faiss::ThreadedIndex&lt; IndexT &gt;::count</definition>
        <argsstring>() const</argsstring>
        <name>count</name>
        <qualifiedname>faiss::ThreadedIndex::count</qualifiedname>
        <briefdescription>
<para>Returns the number of sub-indices. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="50" column="9" bodyfile="faiss/impl/ThreadedIndex.h" bodystart="50" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="classfaiss_1_1ThreadedIndex_1a357254021639c167dedf37fce2427d9d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>IndexT *</type>
        <definition>IndexT * faiss::ThreadedIndex&lt; IndexT &gt;::at</definition>
        <argsstring>(size_t i)</argsstring>
        <name>at</name>
        <qualifiedname>faiss::ThreadedIndex::at</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>Returns the i-th sub-index. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="55" column="12" bodyfile="faiss/impl/ThreadedIndex.h" bodystart="55" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="classfaiss_1_1ThreadedIndex_1a8f8108166de42429361baa030698c119" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const IndexT *</type>
        <definition>const IndexT * faiss::ThreadedIndex&lt; IndexT &gt;::at</definition>
        <argsstring>(size_t i) const</argsstring>
        <name>at</name>
        <qualifiedname>faiss::ThreadedIndex::at</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>Returns the i-th sub-index (const version) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="60" column="18" bodyfile="faiss/impl/ThreadedIndex.h" bodystart="60" bodyend="62"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-func">
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1a1d78dd47e9dc49488947e90dbc85e1ac" prot="protected" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void faiss::IndexShardsTemplate&lt; IndexT &gt;::onAfterAddIndex</definition>
        <argsstring>(IndexT *index) override</argsstring>
        <name>onAfterAddIndex</name>
        <qualifiedname>faiss::IndexShardsTemplate::onAfterAddIndex</qualifiedname>
        <reimplements refid="classfaiss_1_1ThreadedIndex_1abdcae15f8589c53d4fa648fb2d5ab625">onAfterAddIndex</reimplements>
        <param>
          <type>IndexT *</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Called just after an index is added. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="102" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structfaiss_1_1IndexShardsTemplate_1a0488d95e9d45e0cfab203c83e3a8e3c1" prot="protected" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void faiss::IndexShardsTemplate&lt; IndexT &gt;::onAfterRemoveIndex</definition>
        <argsstring>(IndexT *index) override</argsstring>
        <name>onAfterRemoveIndex</name>
        <qualifiedname>faiss::IndexShardsTemplate::onAfterRemoveIndex</qualifiedname>
        <reimplements refid="classfaiss_1_1ThreadedIndex_1a3bfc1a3002a150d850b20dc40c5d31fe">onAfterRemoveIndex</reimplements>
        <param>
          <type>IndexT *</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Called just after an index is removed. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/IndexShards.h" line="105" column="10"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classfaiss_1_1ThreadedIndex_1acb0dc6a321ad80636d5fef5cc7edd05b" prot="protected" static="no" mutable="no">
        <type>std::vector&lt; std::pair&lt; IndexT *, std::unique_ptr&lt; <ref refid="classfaiss_1_1WorkerThread" kindref="compound">WorkerThread</ref> &gt; &gt; &gt;</type>
        <definition>std::vector&lt;std::pair&lt;IndexT*, std::unique_ptr&lt;WorkerThread&gt; &gt; &gt; faiss::ThreadedIndex&lt; IndexT &gt;::indices_</definition>
        <argsstring></argsstring>
        <name>indices_</name>
        <qualifiedname>faiss::ThreadedIndex::indices_</qualifiedname>
        <briefdescription>
<para>Collection of <ref refid="structfaiss_1_1Index" kindref="compound">Index</ref> instances, with their managing worker thread if any. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="78" column="17" bodyfile="faiss/impl/ThreadedIndex.h" bodystart="78" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classfaiss_1_1ThreadedIndex_1a1031b2c900e9ba53573e617539b3c488" prot="protected" static="no" mutable="no">
        <type>bool</type>
        <definition>bool faiss::ThreadedIndex&lt; IndexT &gt;::isThreaded_</definition>
        <argsstring></argsstring>
        <name>isThreaded_</name>
        <qualifiedname>faiss::ThreadedIndex::isThreaded_</qualifiedname>
        <briefdescription>
<para>Is this index multi-threaded? </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="81" column="10" bodyfile="faiss/impl/ThreadedIndex.h" bodystart="81" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-static-func">
      <memberdef kind="function" id="classfaiss_1_1ThreadedIndex_1a4ef2398a63568d069b17ef56a4b3ac09" prot="protected" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void faiss::ThreadedIndex&lt; IndexT &gt;::waitAndHandleFutures</definition>
        <argsstring>(std::vector&lt; std::future&lt; bool &gt; &gt; &amp;v)</argsstring>
        <name>waitAndHandleFutures</name>
        <qualifiedname>faiss::ThreadedIndex::waitAndHandleFutures</qualifiedname>
        <param>
          <type>std::vector&lt; std::future&lt; bool &gt; &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="faiss/impl/ThreadedIndex.h" line="75" column="17" bodyfile="faiss/impl/ThreadedIndex-inl.h" bodystart="170" bodyend="188"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><ref refid="structfaiss_1_1Index" kindref="compound">Index</ref> that concatenates the results from several sub-indexes </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="3">
        <label>IndexT</label>
      </node>
      <node id="4">
        <label>faiss::IndexShardsIVF&lt; Index &gt;</label>
        <link refid="structfaiss_1_1IndexShardsIVF"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>faiss::IndexShardsTemplate&lt; IndexT &gt;</label>
        <link refid="structfaiss_1_1IndexShardsTemplate"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>faiss::ThreadedIndex&lt; IndexT &gt;</label>
        <link refid="classfaiss_1_1ThreadedIndex"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="3">
        <label>IndexT</label>
      </node>
      <node id="1">
        <label>faiss::IndexShardsTemplate&lt; IndexT &gt;</label>
        <link refid="structfaiss_1_1IndexShardsTemplate"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>faiss::ThreadedIndex&lt; IndexT &gt;</label>
        <link refid="classfaiss_1_1ThreadedIndex"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="faiss/IndexShards.h" line="20" column="1" bodyfile="faiss/IndexShards.h" bodystart="20" bodyend="106"/>
    <listofallmembers>
      <member refid="structfaiss_1_1IndexShardsTemplate_1a45647579ff21e0945d8a87a97ec705fe" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>add</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1a47a2e1f78d91025857f483be3eb6828a" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>add_shard</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1a15e0b4a2fd85f9345537d215a331ed91" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>add_with_ids</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a9a11a672369d48f45cf1dd1bfe0dad87" prot="public" virt="virtual"><scope>faiss::IndexShardsTemplate</scope><name>addIndex</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a357254021639c167dedf37fce2427d9d" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>at</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a8f8108166de42429361baa030698c119" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>at</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1ada31784dde1b51d8be8b15288943c559" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>component_t</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a2f9cadbcb9335c0833f61259230429a7" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>count</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1a94570791e9f70d2bef77d76564571417" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>distance_t</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1a2ffc0edbce1815fae55cae188b83a5cf" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>IndexShardsTemplate</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1ac278d8f7d54923cb034127a4257c56b7" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>IndexShardsTemplate</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1a0596f5ca67d6c9bfddae1465c5353b29" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>IndexShardsTemplate</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1acb0dc6a321ad80636d5fef5cc7edd05b" prot="protected" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>indices_</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a1031b2c900e9ba53573e617539b3c488" prot="protected" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>isThreaded_</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1a1d78dd47e9dc49488947e90dbc85e1ac" prot="protected" virt="virtual"><scope>faiss::IndexShardsTemplate</scope><name>onAfterAddIndex</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1a0488d95e9d45e0cfab203c83e3a8e3c1" prot="protected" virt="virtual"><scope>faiss::IndexShardsTemplate</scope><name>onAfterRemoveIndex</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a1223180acd3979e7205c91d2dba9d306" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>own_indices</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1ae0bff98885fecae6c42a474d05563ecd" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>remove_shard</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a21604d6b8b8d42e6cc78c26e85564027" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>removeIndex</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a4536f6e7a8cce1f79bebc420ae1e909b" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>reset</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a30ade89dc4e571868cf121e5592d6687" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>runOnIndex</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1af5188782bc9e776800b96d1610b3f22b" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>runOnIndex</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1ad8c210aad3ef56b82cc5ea47105095f7" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>search</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1aa79db16c723ae37eaf406e840e4f227a" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>successive_ids</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1aaf3c7b44b9f30f17f58aded129eeff58" prot="public" virt="virtual"><scope>faiss::IndexShardsTemplate</scope><name>syncWithSubIndexes</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1ac603a659e678e154a49722bc428538e9" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>ThreadedIndex</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a52a2c216ed16feb3be6a57e15253b368" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>ThreadedIndex</name></member>
      <member refid="structfaiss_1_1IndexShardsTemplate_1aa7d268a8a30e16f52e192d41a57b8626" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>train</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a4ef2398a63568d069b17ef56a4b3ac09" prot="protected" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>waitAndHandleFutures</name></member>
      <member refid="classfaiss_1_1ThreadedIndex_1a79fdffee4cc4aef5dd3d91183e2be5f9" prot="public" virt="non-virtual"><scope>faiss::IndexShardsTemplate</scope><name>~ThreadedIndex</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
