<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="Tensor-inl_8cuh" kind="file" language="C++">
    <compoundname>Tensor-inl.cuh</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Copyright<sp/>(c)<sp/>Facebook,<sp/>Inc.<sp/>and<sp/>its<sp/>affiliates.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>This<sp/>source<sp/>code<sp/>is<sp/>licensed<sp/>under<sp/>the<sp/>MIT<sp/>license<sp/>found<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>LICENSE<sp/>file<sp/>in<sp/>the<sp/>root<sp/>directory<sp/>of<sp/>this<sp/>source<sp/>tree.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;faiss/gpu/GpuFaissAssert.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;faiss/gpu/utils/DeviceUtils.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cstring&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;limits&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>faiss<sp/>{<sp/>namespace<sp/>gpu<sp/>{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::Tensor()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>data_(nullptr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(Dim<sp/>&gt;<sp/>0,<sp/>&quot;must<sp/>have<sp/>&gt;<sp/>0<sp/>dimensions&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stride_[i]<sp/>=<sp/>(IndexT)<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::Tensor(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;&amp;<sp/>t)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>this-&gt;operator=(t);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::Tensor(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;&amp;&amp;<sp/>t)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>this-&gt;operator=(std::move(t));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::operator=(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;&amp;<sp/>t)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data_<sp/>=<sp/>t.data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_[i]<sp/>=<sp/>t.size_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stride_[i]<sp/>=<sp/>t.stride_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::operator=(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;&amp;&amp;<sp/>t)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data_<sp/>=<sp/>t.data_;<sp/>t.data_<sp/>=<sp/>nullptr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stride_[i]<sp/>=<sp/>t.stride_[i];<sp/>t.stride_[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_[i]<sp/>=<sp/>t.size_[i];<sp/>t.size_[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::</highlight></codeline>
<codeline><highlight class="normal">Tensor(DataPtrType<sp/>data,<sp/>const<sp/>IndexT<sp/>sizes[Dim])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>data_(data)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(Dim<sp/>&gt;<sp/>0,<sp/>&quot;must<sp/>have<sp/>&gt;<sp/>0<sp/>dimensions&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_[i]<sp/>=<sp/>sizes[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>stride_[Dim<sp/>-<sp/>1]<sp/>=<sp/>(IndexT)<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>Dim<sp/>-<sp/>2;<sp/>i<sp/>&gt;=<sp/>0;<sp/>--i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stride_[i]<sp/>=<sp/>stride_[i<sp/>+<sp/>1]<sp/>*<sp/>sizes[i<sp/>+<sp/>1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::</highlight></codeline>
<codeline><highlight class="normal">Tensor(DataPtrType<sp/>data,<sp/>std::initializer_list&lt;IndexT&gt;<sp/>sizes)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>data_(data)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(sizes.size()<sp/>==<sp/>Dim);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(Dim<sp/>&gt;<sp/>0,<sp/>&quot;must<sp/>have<sp/>&gt;<sp/>0<sp/>dimensions&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>i<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(auto<sp/>s<sp/>:<sp/>sizes)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_[i++]<sp/>=<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>stride_[Dim<sp/>-<sp/>1]<sp/>=<sp/>(IndexT)<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>j<sp/>=<sp/>Dim<sp/>-<sp/>2;<sp/>j<sp/>&gt;=<sp/>0;<sp/>--j)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stride_[j]<sp/>=<sp/>stride_[j<sp/>+<sp/>1]<sp/>*<sp/>size_[j<sp/>+<sp/>1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::Tensor(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DataPtrType<sp/>data,<sp/>const<sp/>IndexT<sp/>sizes[Dim],<sp/>const<sp/>IndexT<sp/>strides[Dim])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>data_(data)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(Dim<sp/>&gt;<sp/>0,<sp/>&quot;must<sp/>have<sp/>&gt;<sp/>0<sp/>dimensions&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_[i]<sp/>=<sp/>sizes[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stride_[i]<sp/>=<sp/>strides[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>void</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::copyFrom(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;&amp;<sp/>t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cudaStream_t<sp/>stream)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>tensor<sp/>must<sp/>be<sp/>fully<sp/>contiguous</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;isContiguous());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Size<sp/>must<sp/>be<sp/>the<sp/>same<sp/>(since<sp/>dimensions<sp/>are<sp/>checked<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>continuity<sp/>is<sp/>assumed,<sp/>we<sp/>need<sp/>only<sp/>check<sp/>total<sp/>number<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>elements</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;numElements()<sp/>==<sp/>t.numElements());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(t.numElements()<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;data_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPU_FAISS_ASSERT(t.data());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>ourDev<sp/>=<sp/>getDeviceForAddress(this-&gt;data_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>tDev<sp/>=<sp/>getDeviceForAddress(t.data());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(tDev<sp/>==<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_VERIFY(cudaMemcpyAsync(this-&gt;data_,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t.data(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this-&gt;getSizeInBytes(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ourDev<sp/>==<sp/>-1<sp/>?<sp/>cudaMemcpyHostToHost<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyHostToDevice,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_VERIFY(cudaMemcpyAsync(this-&gt;data_,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t.data(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this-&gt;getSizeInBytes(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ourDev<sp/>==<sp/>-1<sp/>?<sp/>cudaMemcpyDeviceToHost<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyDeviceToDevice,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>void</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::copyTo(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;&amp;<sp/>t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cudaStream_t<sp/>stream)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>tensor<sp/>must<sp/>be<sp/>fully<sp/>contiguous</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;isContiguous());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Size<sp/>must<sp/>be<sp/>the<sp/>same<sp/>(since<sp/>dimensions<sp/>are<sp/>checked<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>continuity<sp/>is<sp/>assumed,<sp/>we<sp/>need<sp/>only<sp/>check<sp/>total<sp/>number<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>elements</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;numElements()<sp/>==<sp/>t.numElements());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(t.numElements()<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;data_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPU_FAISS_ASSERT(t.data());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>ourDev<sp/>=<sp/>getDeviceForAddress(this-&gt;data_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>tDev<sp/>=<sp/>getDeviceForAddress(t.data());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(tDev<sp/>==<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_VERIFY(cudaMemcpyAsync(t.data(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this-&gt;data_,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this-&gt;getSizeInBytes(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ourDev<sp/>==<sp/>-1<sp/>?<sp/>cudaMemcpyHostToHost<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyDeviceToHost,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_VERIFY(cudaMemcpyAsync(t.data(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this-&gt;data_,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this-&gt;getSizeInBytes(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ourDev<sp/>==<sp/>-1<sp/>?<sp/>cudaMemcpyHostToDevice<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyDeviceToDevice,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>void</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::copyFrom(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>std::vector&lt;T&gt;&amp;<sp/>v,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cudaStream_t<sp/>stream)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>tensor<sp/>must<sp/>be<sp/>fully<sp/>contiguous</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;isContiguous());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Size<sp/>must<sp/>be<sp/>the<sp/>same</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;numElements()<sp/>==<sp/>v.size());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(v.size()<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;data_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>ourDev<sp/>=<sp/>getDeviceForAddress(this-&gt;data_);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_VERIFY(cudaMemcpyAsync(this-&gt;data_,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v.data(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this-&gt;getSizeInBytes(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ourDev<sp/>==<sp/>-1<sp/>?<sp/>cudaMemcpyHostToHost<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyHostToDevice,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>std::vector&lt;T&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::copyToVector(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cudaStream_t<sp/>stream)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>tensor<sp/>must<sp/>be<sp/>fully<sp/>contiguous</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;isContiguous());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;T&gt;<sp/>out(this-&gt;numElements());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!out.empty())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>ourDev<sp/>=<sp/>getDeviceForAddress(this-&gt;data_);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ourDev<sp/>==<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::memcpy(out.data(),<sp/>this-&gt;data_,<sp/>this-&gt;numElements()<sp/>*<sp/>sizeof(T));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_VERIFY(cudaMemcpyAsync(out.data(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this-&gt;data_,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this-&gt;numElements()<sp/>*<sp/>sizeof(T),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyDeviceToHost,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>out;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>OtherT,<sp/>int<sp/>OtherDim&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>bool</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::isSame(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Tensor&lt;OtherT,<sp/>OtherDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;&amp;<sp/>rhs)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(Dim<sp/>!=<sp/>OtherDim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(this-&gt;getSize(i)<sp/>!=<sp/>rhs.getSize(i))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(this-&gt;getStride(i)<sp/>!=<sp/>rhs.getStride(i))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>OtherT,<sp/>int<sp/>OtherDim&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>bool</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::isSameSize(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Tensor&lt;OtherT,<sp/>OtherDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;&amp;<sp/>rhs)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(Dim<sp/>!=<sp/>OtherDim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(this-&gt;getSize(i)<sp/>!=<sp/>rhs.getSize(i))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>U&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;U,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::cast()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(sizeof(U)<sp/>==<sp/>sizeof(T),<sp/>&quot;cast<sp/>must<sp/>be<sp/>to<sp/>same<sp/>size<sp/>object&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;U,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reinterpret_cast&lt;U*&gt;(data_),<sp/>size_,<sp/>stride_);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>U&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>const<sp/>Tensor&lt;U,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::cast()<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(sizeof(U)<sp/>==<sp/>sizeof(T),<sp/>&quot;cast<sp/>must<sp/>be<sp/>to<sp/>same<sp/>size<sp/>object&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;U,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reinterpret_cast&lt;U*&gt;(data_),<sp/>size_,<sp/>stride_);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>U&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;U,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::castResize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(sizeof(U)<sp/>&gt;=<sp/>sizeof(T),<sp/>&quot;only<sp/>handles<sp/>greater<sp/>sizes&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>constexpr<sp/>int<sp/>kMultiple<sp/>=<sp/>sizeof(U)<sp/>/<sp/>sizeof(T);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(canCastResize&lt;U&gt;());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newSize[Dim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newStride[Dim];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>size_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>newStride[i]<sp/>=<sp/>stride_[i]<sp/>/<sp/>kMultiple;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>newStride[Dim<sp/>-<sp/>1]<sp/>=<sp/>1;<sp/>//<sp/>this<sp/>is<sp/>the<sp/>same<sp/>as<sp/>the<sp/>old<sp/>stride</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>newSize[Dim<sp/>-<sp/>1]<sp/>=<sp/>size_[Dim<sp/>-<sp/>1]<sp/>/<sp/>kMultiple;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;U,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reinterpret_cast&lt;U*&gt;(data_),<sp/>newSize,<sp/>newStride);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>U&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>const<sp/>Tensor&lt;U,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::castResize()<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>const_cast&lt;Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;*&gt;(this)-&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>castResize&lt;U&gt;();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>U&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>bool</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::canCastResize()<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(sizeof(U)<sp/>&gt;=<sp/>sizeof(T),<sp/>&quot;only<sp/>handles<sp/>greater<sp/>sizes&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>constexpr<sp/>int<sp/>kMultiple<sp/>=<sp/>sizeof(U)<sp/>/<sp/>sizeof(T);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Ensure<sp/>that<sp/>the<sp/>base<sp/>pointer<sp/>is<sp/>sizeof(U)<sp/>aligned</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(((uintptr_t)<sp/>data_)<sp/>%<sp/>sizeof(U)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Check<sp/>all<sp/>outer<sp/>strides</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(stride_[i]<sp/>%<sp/>kMultiple<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Check<sp/>inner<sp/>size</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(size_[Dim<sp/>-<sp/>1]<sp/>%<sp/>kMultiple<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(stride_[Dim<sp/>-<sp/>1]<sp/>!=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>NewIndexT&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>NewIndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::castIndexType()<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(sizeof(NewIndexT)<sp/>&lt;<sp/>sizeof(IndexT))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;canUseIndexType&lt;NewIndexT&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>NewIndexT<sp/>newSize[Dim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NewIndexT<sp/>newStride[Dim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>(NewIndexT)<sp/>size_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>newStride[i]<sp/>=<sp/>(NewIndexT)<sp/>stride_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>NewIndexT,<sp/>PtrTraits&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data_,<sp/>newSize,<sp/>newStride);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>NewIndexT&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>bool</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::canUseIndexType()<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(sizeof(size_t)<sp/>&gt;=<sp/>sizeof(IndexT),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;index<sp/>size<sp/>too<sp/>large&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(sizeof(size_t)<sp/>&gt;=<sp/>sizeof(NewIndexT),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;new<sp/>index<sp/>size<sp/>too<sp/>large&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>maximum<sp/>offset<sp/>that<sp/>can<sp/>be<sp/>calculated</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>FIXME:<sp/>maybe<sp/>also<sp/>consider<sp/>offset<sp/>in<sp/>bytes?<sp/>multiply<sp/>by<sp/>sizeof(T)?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>maxOffset<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>curMaxOffset<sp/>=<sp/>(size_t)<sp/>size_[i]<sp/>*<sp/>(size_t)<sp/>stride_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(curMaxOffset<sp/>&gt;<sp/>maxOffset)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>maxOffset<sp/>=<sp/>curMaxOffset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(maxOffset<sp/>&gt;<sp/>(size_t)<sp/>std::numeric_limits&lt;NewIndexT&gt;::max())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>size_t</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::numElements()<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>size<sp/>=<sp/>(size_t)<sp/>getSize(0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>1;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size<sp/>*=<sp/>(size_t)<sp/>getSize(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>size;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>bool</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::isContiguous()<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>long<sp/>prevSize<sp/>=<sp/>1;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>Dim<sp/>-<sp/>1;<sp/>i<sp/>&gt;=<sp/>0;<sp/>--i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(getSize(i)<sp/>!=<sp/>(IndexT)<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(getStride(i)<sp/>==<sp/>prevSize)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevSize<sp/>*=<sp/>getSize(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>bool</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::isConsistentlySized(int<sp/>i)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(i<sp/>==<sp/>0<sp/>&amp;&amp;<sp/>getStride(i)<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>getSize(i)<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>if<sp/>((i<sp/>&gt;<sp/>0)<sp/>&amp;&amp;<sp/>(i<sp/>&lt;<sp/>Dim)<sp/>&amp;&amp;<sp/>(getStride(i)<sp/>&gt;<sp/>0)<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((getStride(i<sp/>-<sp/>1)<sp/>/<sp/>getStride(i))<sp/>&gt;=<sp/>getSize(i)))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>bool</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::isConsistentlySized()<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!isConsistentlySized(i))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>bool</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::isContiguousDim(int<sp/>i)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>(i<sp/>==<sp/>Dim<sp/>-<sp/>1)<sp/>||<sp/>//<sp/>just<sp/>in<sp/>case</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>((i<sp/>&lt;<sp/>Dim<sp/>-<sp/>1)<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>((getStride(i)<sp/>/<sp/>getStride(i<sp/>+<sp/>1))<sp/>==<sp/>getSize(i<sp/>+<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::transpose(int<sp/>dim1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>dim2)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(dim1<sp/>&gt;=<sp/>0<sp/>&amp;&amp;<sp/>dim1<sp/>&lt;<sp/>Dim);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(dim1<sp/>&gt;=<sp/>0<sp/>&amp;&amp;<sp/>dim2<sp/>&lt;<sp/>Dim);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>If<sp/>a<sp/>tensor<sp/>is<sp/>innermost<sp/>contiguous,<sp/>one<sp/>cannot<sp/>transpose<sp/>the<sp/>innermost</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>dimension</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(InnerContig)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPU_FAISS_ASSERT(dim1<sp/>!=<sp/>Dim<sp/>-<sp/>1<sp/>&amp;&amp;<sp/>dim2<sp/>!=<sp/>Dim<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newSize[Dim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newStride[Dim];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>size_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>newStride[i]<sp/>=<sp/>stride_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>tmp<sp/>=<sp/>newSize[dim1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>newSize[dim1]<sp/>=<sp/>newSize[dim2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>newSize[dim2]<sp/>=<sp/>tmp;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp<sp/>=<sp/>newStride[dim1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>newStride[dim1]<sp/>=<sp/>newStride[dim2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>newStride[dim2]<sp/>=<sp/>tmp;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;T,<sp/>Dim,<sp/>true,<sp/>IndexT,<sp/>PtrTraits&gt;(data_,<sp/>newSize,<sp/>newStride);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;T,<sp/>Dim,<sp/>false,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::transposeInnermost(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>dim1)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(dim1<sp/>&gt;=<sp/>0<sp/>&amp;&amp;<sp/>dim1<sp/>&lt;<sp/>Dim);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>We<sp/>are<sp/>exchanging<sp/>with<sp/>the<sp/>innermost<sp/>dimension</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>dim2<sp/>=<sp/>1;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newSize[Dim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newStride[Dim];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>size_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>newStride[i]<sp/>=<sp/>stride_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>tmp<sp/>=<sp/>newSize[dim1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>newSize[dim1]<sp/>=<sp/>newSize[dim2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>newSize[dim2]<sp/>=<sp/>tmp;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp<sp/>=<sp/>newStride[dim1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>newStride[dim1]<sp/>=<sp/>newStride[dim2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>newStride[dim2]<sp/>=<sp/>tmp;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;T,<sp/>Dim,<sp/>false,<sp/>IndexT,<sp/>PtrTraits&gt;(data_,<sp/>newSize,<sp/>newStride);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;int<sp/>NewDim&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;T,<sp/>NewDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::upcastOuter()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Can<sp/>only<sp/>create<sp/>tensors<sp/>of<sp/>greater<sp/>dimension</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(NewDim<sp/>&gt;<sp/>Dim,<sp/>&quot;Can<sp/>only<sp/>upcast<sp/>to<sp/>greater<sp/>dim&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newSize[NewDim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newStride[NewDim];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>shift<sp/>=<sp/>NewDim<sp/>-<sp/>Dim;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>NewDim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>&lt;<sp/>shift)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>These<sp/>are<sp/>the<sp/>extended<sp/>dimensions</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>(IndexT)<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>newStride[i]<sp/>=<sp/>size_[0]<sp/>*<sp/>stride_[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Shift<sp/>the<sp/>remaining<sp/>dimensions</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>size_[i<sp/>-<sp/>shift];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>newStride[i]<sp/>=<sp/>stride_[i<sp/>-<sp/>shift];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;T,<sp/>NewDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data_,<sp/>newSize,<sp/>newStride);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;int<sp/>NewDim&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;T,<sp/>NewDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::upcastInner()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Can<sp/>only<sp/>create<sp/>tensors<sp/>of<sp/>greater<sp/>dimension</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(NewDim<sp/>&gt;<sp/>Dim,<sp/>&quot;Can<sp/>only<sp/>upcast<sp/>to<sp/>greater<sp/>dim&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newSize[NewDim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newStride[NewDim];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>NewDim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>&lt;<sp/>Dim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Existing<sp/>dimensions<sp/>get<sp/>copied<sp/>over</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>size_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>newStride[i]<sp/>=<sp/>stride_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Extended<sp/>dimensions</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>(IndexT)<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>newStride[i]<sp/>=<sp/>(IndexT)<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;T,<sp/>NewDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data_,<sp/>newSize,<sp/>newStride);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;int<sp/>NewDim&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;T,<sp/>NewDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::downcastOuter()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Can<sp/>only<sp/>create<sp/>tensors<sp/>of<sp/>lesser<sp/>dimension</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(NewDim<sp/>&lt;<sp/>Dim,<sp/>&quot;Can<sp/>only<sp/>downcast<sp/>to<sp/>lesser<sp/>dim&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>We<sp/>can&apos;t<sp/>downcast<sp/>non-contiguous<sp/>tensors,<sp/>since<sp/>it<sp/>leaves</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>garbage<sp/>data<sp/>in<sp/>the<sp/>tensor.<sp/>The<sp/>tensor<sp/>needs<sp/>to<sp/>be<sp/>contiguous</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>in<sp/>all<sp/>of<sp/>the<sp/>dimensions<sp/>we<sp/>are<sp/>collapsing<sp/>(no<sp/>padding<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>them).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim<sp/>-<sp/>NewDim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>cont<sp/>=<sp/>isContiguousDim(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPU_FAISS_ASSERT(cont);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newSize[NewDim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newStride[NewDim];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>ignoredDims<sp/>=<sp/>Dim<sp/>-<sp/>NewDim;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>collapsedSize<sp/>=<sp/>1;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>&lt;<sp/>ignoredDims)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Collapse<sp/>these<sp/>dimensions</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>collapsedSize<sp/>*=<sp/>getSize(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Non-collapsed<sp/>dimensions</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>ignoredDims)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>This<sp/>is<sp/>the<sp/>first<sp/>non-collapsed<sp/>dimension</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newSize[i<sp/>-<sp/>ignoredDims]<sp/>=<sp/>collapsedSize<sp/>*<sp/>getSize(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Subsequent<sp/>non-collapsed<sp/>dimensions</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newSize[i<sp/>-<sp/>ignoredDims]<sp/>=<sp/>getSize(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>newStride[i<sp/>-<sp/>ignoredDims]<sp/>=<sp/>getStride(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;T,<sp/>NewDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data_,<sp/>newSize,<sp/>newStride);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;int<sp/>NewDim&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;T,<sp/>NewDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::downcastInner()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Can<sp/>only<sp/>create<sp/>tensors<sp/>of<sp/>lesser<sp/>dimension</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(NewDim<sp/>&lt;<sp/>Dim,<sp/>&quot;Can<sp/>only<sp/>downcast<sp/>to<sp/>lesser<sp/>dim&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>We<sp/>can&apos;t<sp/>downcast<sp/>non-contiguous<sp/>tensors,<sp/>since<sp/>it<sp/>leaves</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>garbage<sp/>data<sp/>in<sp/>the<sp/>tensor.<sp/>The<sp/>tensor<sp/>needs<sp/>to<sp/>be<sp/>contiguous</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>in<sp/>all<sp/>of<sp/>the<sp/>dimensions<sp/>we<sp/>are<sp/>collapsing<sp/>(no<sp/>padding<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>them).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>NewDim;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GPU_FAISS_ASSERT(isContiguousDim(i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newSize[NewDim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newStride[NewDim];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>collapsedSize<sp/>=<sp/>1;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>Dim<sp/>-<sp/>1;<sp/>i<sp/>&gt;=<sp/>0;<sp/>--i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>&gt;=<sp/>NewDim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Collapse<sp/>these<sp/>dimensions</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>collapsedSize<sp/>*=<sp/>getSize(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Non-collapsed<sp/>dimensions</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>NewDim<sp/>-<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>This<sp/>is<sp/>the<sp/>first<sp/>non-collapsed<sp/>dimension</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>collapsedSize<sp/>*<sp/>getSize(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newStride[i]<sp/>=<sp/>getStride(Dim<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Subsequent<sp/>non-collapsed<sp/>dimensions</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>getSize(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newStride[i]<sp/>=<sp/>getStride(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;T,<sp/>NewDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data_,<sp/>newSize,<sp/>newStride);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;int<sp/>SubDim&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;T,<sp/>SubDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::view(DataPtrType<sp/>at)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(SubDim<sp/>&gt;=<sp/>1<sp/>&amp;&amp;<sp/>SubDim<sp/>&lt;<sp/>Dim,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;can<sp/>only<sp/>create<sp/>view<sp/>of<sp/>lesser<sp/>dim&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>viewSizes[SubDim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>viewStrides[SubDim];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>SubDim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>viewSizes[i]<sp/>=<sp/>size_[Dim<sp/>-<sp/>SubDim<sp/>+<sp/>i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>viewStrides[i]<sp/>=<sp/>stride_[Dim<sp/>-<sp/>SubDim<sp/>+<sp/>i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;T,<sp/>SubDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>at,<sp/>viewSizes,<sp/>viewStrides);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;int<sp/>SubDim&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;T,<sp/>SubDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::view()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>view&lt;SubDim&gt;(data_);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::narrowOutermost(IndexT<sp/>start,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IndexT<sp/>size)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>this-&gt;narrow(0,<sp/>start,<sp/>size);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::narrow(int<sp/>dim,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IndexT<sp/>start,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IndexT<sp/>size)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DataPtrType<sp/>newData<sp/>=<sp/>data_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(start<sp/>&gt;=<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>start<sp/>&lt;<sp/>size_[dim]<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(start<sp/>+<sp/>size)<sp/>&lt;=<sp/>size_[dim]);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(start<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>newData<sp/>+=<sp/>(size_t)<sp/>start<sp/>*<sp/>stride_[dim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT<sp/>newSize[Dim];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>dim)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>GPU_FAISS_ASSERT(start<sp/>+<sp/>size<sp/>&lt;=<sp/>size_[dim]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>newSize[i]<sp/>=<sp/>size_[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>If<sp/>we<sp/>were<sp/>innermost<sp/>contiguous<sp/>before,<sp/>we<sp/>are<sp/>still<sp/>innermost<sp/>contiguous</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;(newData,<sp/>newSize,<sp/>stride_);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T,<sp/>int<sp/>Dim,<sp/>bool<sp/>InnerContig,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,<sp/>template<sp/>&lt;typename<sp/>U&gt;<sp/>class<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;int<sp/>NewDim&gt;</highlight></codeline>
<codeline><highlight class="normal">__host__<sp/>__device__<sp/>Tensor&lt;T,<sp/>NewDim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;</highlight></codeline>
<codeline><highlight class="normal">Tensor&lt;T,<sp/>Dim,<sp/>InnerContig,<sp/>IndexT,<sp/>PtrTraits&gt;::view(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::initializer_list&lt;IndexT&gt;<sp/>sizes)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(this-&gt;isContiguous());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(sizes.size()<sp/>==<sp/>NewDim);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>total<sp/>size<sp/>of<sp/>the<sp/>new<sp/>view<sp/>must<sp/>be<sp/>the<sp/>same<sp/>as<sp/>the<sp/>total<sp/>size</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>of<sp/>the<sp/>old<sp/>view</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>curSize<sp/>=<sp/>numElements();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>newSize<sp/>=<sp/>1;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(auto<sp/>s<sp/>:<sp/>sizes)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>newSize<sp/>*=<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>GPU_FAISS_ASSERT(curSize<sp/>==<sp/>newSize);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>Tensor&lt;T,<sp/>NewDim,<sp/>true,<sp/>IndexT,<sp/>PtrTraits&gt;(data(),<sp/>sizes);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">}<sp/>}<sp/>//<sp/>namespace</highlight></codeline>
    </programlisting>
    <location file="faiss/gpu/utils/Tensor-inl.cuh"/>
  </compounddef>
</doxygen>
