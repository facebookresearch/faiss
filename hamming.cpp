/bin /boot /chef_reboot_override /chef_reboot_required /chef_reboot_trigger /data /dev /etc /fblearner_canary_tmp /fblearner_tmp /gfsai-bistro-east /gfsai-bistro-oregon /gfsai-east /gfsai-flash-east /gfsai-oregon /home /hphp /lib /lib64 /lost+found /mcrouter-web /media /mnt /opt /proc /root /run /sbin /sftp /srv /sys /tmp /usr /var /version-web AutoTune.cpp AutoTune.h AuxIndexStructures.cpp AuxIndexStructures.h benchs BinaryCode.cpp BinaryCode.h c Clustering.cpp Clustering.h example_makefiles FaissAssert.h faiss.h faiss.py gpu hamming.cpp hamming.h Heap.cpp Heap.h Index.cpp IndexFlat.cpp IndexFlat.h Index.h index_io.cpp index_io.h IndexIVF.cpp IndexIVF.h IndexIVFPQ.cpp IndexIVFPQ.h IndexLSH.cpp IndexLSH.h IndexNested.cpp IndexNested.h IndexPQ.cpp IndexPQ.h INSTALL knngraph_nndescent.cpp knngraph_nndescent.h lua Makefile #MetaIndexes.cpp# MetaIndexes.cpp #MetaIndexes.h# MetaIndexes.h PolysemousTraining.cpp PolysemousTraining.h #ProductQuantizer.cpp# ProductQuantizer.cpp ProductQuantizer.h python python_history README scripts shipit-hack.bash shipit-hack.bash~ swigfaiss.swig TARGETS tests tutorial utils.cpp utils.h VectorTransform.cpp VectorTransform.h Copyright (c) 2015-present, Facebook, Inc. AutoTune.cpp AutoTune.h AuxIndexStructures.cpp AuxIndexStructures.h benchs BinaryCode.cpp BinaryCode.h c Clustering.cpp Clustering.h example_makefiles FaissAssert.h faiss.h faiss.py gpu hamming.cpp hamming.h Heap.cpp Heap.h Index.cpp IndexFlat.cpp IndexFlat.h Index.h index_io.cpp index_io.h IndexIVF.cpp IndexIVF.h IndexIVFPQ.cpp IndexIVFPQ.h IndexLSH.cpp IndexLSH.h IndexNested.cpp IndexNested.h IndexPQ.cpp IndexPQ.h INSTALL knngraph_nndescent.cpp knngraph_nndescent.h lua Makefile #MetaIndexes.cpp# MetaIndexes.cpp #MetaIndexes.h# MetaIndexes.h PolysemousTraining.cpp PolysemousTraining.h #ProductQuantizer.cpp# ProductQuantizer.cpp ProductQuantizer.h python python_history README scripts shipit-hack.bash shipit-hack.bash~ swigfaiss.swig TARGETS tests tutorial utils.cpp utils.h VectorTransform.cpp VectorTransform.h All rights reserved. AutoTune.cpp AutoTune.h AuxIndexStructures.cpp AuxIndexStructures.h benchs BinaryCode.cpp BinaryCode.h c Clustering.cpp Clustering.h example_makefiles FaissAssert.h faiss.h faiss.py gpu hamming.cpp hamming.h Heap.cpp Heap.h Index.cpp IndexFlat.cpp IndexFlat.h Index.h index_io.cpp index_io.h IndexIVF.cpp IndexIVF.h IndexIVFPQ.cpp IndexIVFPQ.h IndexLSH.cpp IndexLSH.h IndexNested.cpp IndexNested.h IndexPQ.cpp IndexPQ.h INSTALL knngraph_nndescent.cpp knngraph_nndescent.h lua Makefile #MetaIndexes.cpp# MetaIndexes.cpp #MetaIndexes.h# MetaIndexes.h PolysemousTraining.cpp PolysemousTraining.h #ProductQuantizer.cpp# ProductQuantizer.cpp ProductQuantizer.h python python_history README scripts shipit-hack.bash shipit-hack.bash~ swigfaiss.swig TARGETS tests tutorial utils.cpp utils.h VectorTransform.cpp VectorTransform.h AutoTune.cpp AutoTune.h AuxIndexStructures.cpp AuxIndexStructures.h benchs BinaryCode.cpp BinaryCode.h c Clustering.cpp Clustering.h example_makefiles FaissAssert.h faiss.h faiss.py gpu hamming.cpp hamming.h Heap.cpp Heap.h Index.cpp IndexFlat.cpp IndexFlat.h Index.h index_io.cpp index_io.h IndexIVF.cpp IndexIVF.h IndexIVFPQ.cpp IndexIVFPQ.h IndexLSH.cpp IndexLSH.h IndexNested.cpp IndexNested.h IndexPQ.cpp IndexPQ.h INSTALL knngraph_nndescent.cpp knngraph_nndescent.h lua Makefile #MetaIndexes.cpp# MetaIndexes.cpp #MetaIndexes.h# MetaIndexes.h PolysemousTraining.cpp PolysemousTraining.h #ProductQuantizer.cpp# ProductQuantizer.cpp ProductQuantizer.h python python_history README scripts shipit-hack.bash shipit-hack.bash~ swigfaiss.swig TARGETS tests tutorial utils.cpp utils.h VectorTransform.cpp VectorTransform.h This source code is licensed under the CC-by-NC license found in the AutoTune.cpp AutoTune.h AuxIndexStructures.cpp AuxIndexStructures.h benchs BinaryCode.cpp BinaryCode.h c Clustering.cpp Clustering.h example_makefiles FaissAssert.h faiss.h faiss.py gpu hamming.cpp hamming.h Heap.cpp Heap.h Index.cpp IndexFlat.cpp IndexFlat.h Index.h index_io.cpp index_io.h IndexIVF.cpp IndexIVF.h IndexIVFPQ.cpp IndexIVFPQ.h IndexLSH.cpp IndexLSH.h IndexNested.cpp IndexNested.h IndexPQ.cpp IndexPQ.h INSTALL knngraph_nndescent.cpp knngraph_nndescent.h lua Makefile #MetaIndexes.cpp# MetaIndexes.cpp #MetaIndexes.h# MetaIndexes.h PolysemousTraining.cpp PolysemousTraining.h #ProductQuantizer.cpp# ProductQuantizer.cpp ProductQuantizer.h python python_history README scripts shipit-hack.bash shipit-hack.bash~ swigfaiss.swig TARGETS tests tutorial utils.cpp utils.h VectorTransform.cpp VectorTransform.h LICENSE file in the root directory of this source tree. An additional grant AutoTune.cpp AutoTune.h AuxIndexStructures.cpp AuxIndexStructures.h benchs BinaryCode.cpp BinaryCode.h c Clustering.cpp Clustering.h example_makefiles FaissAssert.h faiss.h faiss.py gpu hamming.cpp hamming.h Heap.cpp Heap.h Index.cpp IndexFlat.cpp IndexFlat.h Index.h index_io.cpp index_io.h IndexIVF.cpp IndexIVF.h IndexIVFPQ.cpp IndexIVFPQ.h IndexLSH.cpp IndexLSH.h IndexNested.cpp IndexNested.h IndexPQ.cpp IndexPQ.h INSTALL knngraph_nndescent.cpp knngraph_nndescent.h lua Makefile #MetaIndexes.cpp# MetaIndexes.cpp #MetaIndexes.h# MetaIndexes.h PolysemousTraining.cpp PolysemousTraining.h #ProductQuantizer.cpp# ProductQuantizer.cpp ProductQuantizer.h python python_history README scripts shipit-hack.bash shipit-hack.bash~ swigfaiss.swig TARGETS tests tutorial utils.cpp utils.h VectorTransform.cpp VectorTransform.h of patent rights can be found in the PATENTS file in the same directory. benchs/ c/ example_makefiles/ gpu/ lua/ python/ scripts/ tests/ tutorial/
/* Copyright 2004-present Facebook. All Rights Reserved.
 *
 * Implementation of Hamming related functions (distances, smallest distance
 * selection with regular heap|radix and probabilistic heap|radix.
 *
 * IMPLEMENTATION NOTES
 * Bitvectors are generally assumed to be multiples of 64 bits.
 *
 * hamdis_t is used for distances because at this time
 * it is not clear how we will need to balance
 * - flexibility in vector size (unclear more than 2^16 or even 2^8 bitvectors)
 * - memory usage
 * - cache-misses when dealing with large volumes of data (lower bits is better)
 *
 * The hamdis_t should optimally be compatibe with one of the Torch Storage
 * (Byte,Short,Long) and therefore should be signed for 2-bytes and 4-bytes
*/

#include "hamming.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <assert.h>
#include <limits.h>

#include "faiss.h"
#include "Heap.h"
#include "FaissAssert.h"

static const size_t BLOCKSIZE_QUERY = 8192;


namespace faiss {

static const uint8_t hamdis_tab_ham_bytes[256] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
};


/* Elementary Hamming distance computation: unoptimized  */
template <size_t nbits, typename T>
T hamming (const uint8_t *bs1,
           const uint8_t *bs2)
{
    const size_t nbytes = nbits / 8;
    size_t i;
    T h = 0;
    for (i = 0; i < nbytes; i++)
        h += (T) hamdis_tab_ham_bytes[bs1[i]^bs2[i]];
    return h;
}


/* Hamming distances for multiples of 64 bits */
template <size_t nbits>
hamdis_t hamming (const uint64_t * bs1, const uint64_t * bs2)
{
    const size_t nwords = nbits / 64;
    size_t i;
    hamdis_t h = 0;
    for (i = 0; i < nwords; i++)
        h += popcount64 (bs1[i] ^ bs2[i]);
    return h;
}



/* specialized (optimized) functions */
template <>
hamdis_t hamming<64> (const uint64_t * pa, const uint64_t * pb)
{
    return popcount64 (pa[0] ^ pb[0]);
}


template <>
hamdis_t hamming<128> (const uint64_t *pa, const uint64_t *pb)
{
    return popcount64 (pa[0] ^ pb[0]) + popcount64(pa[1] ^ pb[1]);
}


template <>
hamdis_t hamming<256> (const uint64_t * pa, const uint64_t * pb)
{
    return  popcount64 (pa[0] ^ pb[0])
          + popcount64 (pa[1] ^ pb[1])
          + popcount64 (pa[2] ^ pb[2])
          + popcount64 (pa[3] ^ pb[3]);
}


/* Hamming distances for multiple of 64 bits */
hamdis_t hamming (
        const uint64_t * bs1,
        const uint64_t * bs2,
        size_t nwords)
{
    size_t i;
    hamdis_t h = 0;
    for (i = 0; i < nwords; i++)
        h += popcount64 (bs1[i] ^ bs2[i]);
    return h;
}



template <size_t nbits>
void hammings (
        const uint64_t * bs1,
        const uint64_t * bs2,
        size_t n1, size_t n2,
        hamdis_t * dis)

{
    size_t i, j;
    const size_t nwords = nbits / 64;
    for (i = 0; i < n1; i++) {
      const uint64_t * __restrict bs1_ = bs1 + i * nwords;
      hamdis_t * __restrict dis_ = dis + i * n2;
      for (j = 0; j < n2; j++)
        dis_[j] = hamming<nbits>(bs1_, bs2 + j * nwords);
    }
}



void hammings (
        const uint64_t * bs1,
        const uint64_t * bs2,
        size_t n1,
        size_t n2,
        size_t nwords,
        hamdis_t * __restrict dis)
{
    size_t i, j;
    n1 *= nwords;
    n2 *= nwords;
    for (i = 0; i < n1; i+=nwords) {
        const uint64_t * bs1_ = bs1+i;
        for (j = 0; j < n2; j+=nwords)
            dis[j] = hamming (bs1_, bs2+j, nwords);
    }
}



/* Return closest neighbors w.r.t Hamming distance */
template <size_t nbits>
void hammings_knn_softheap (
        int_maxheap_array_t * ha,
        const uint64_t * bs1,
        const uint64_t * bs2,
        size_t n2,
        size_t blocksize,
        double delta,
        bool order = true)
{
    const size_t nwords = nbits / 64;
    size_t j, t, k = ha->k;
    size_t n1 = ha->nh;
    const size_t T = (long) ceill (n2 / (double) blocksize);
    size_t * ki = new size_t[T];
    size_t * ti = new size_t[T];
    size_t * posused = new size_t[n1];
    SET_NT (ha->nh);

    if (blocksize > n2)
        blocksize = n2;

    /* Initialization */
    for (t = 0; t < T; t++)
        ti[t] = (t+1) * blocksize;
    ti[T-1] = n2;
    const size_t k0 = softheap_capacity (n2, k, T, ti, ki, delta);

    size_t jstart;
    for (jstart = 0 ; jstart < n1; jstart += BLOCKSIZE_QUERY) {
        size_t jend = jstart + BLOCKSIZE_QUERY;
        if (jend > n1)
            jend = n1;

        for (t = 0; t < T; t++) {
            const size_t istart = (t > 0 ? ti[t-1] : k0);
            const size_t iend = ti[t];
            const size_t kit = ki[t];
            if (iend <= istart && t > 0) continue;

            #pragma omp parallel for private(j) num_threads(nt)
            for (j = jstart; j < jend; j++) {
                size_t i;
                int * __restrict bh_val = ha->val + j * k;
                long * __restrict bh_ids = ha->ids + j * k;
                const uint64_t * bs1_ = bs1 + j * nwords;
                hamdis_t dis;

                /* Particular case of 1st block (heapify for initialization) */
                if (t == 0) {
                    maxheap_heapify<hamdis_t> (k, bh_val, bh_ids);
                    for (i = 0 ; i < k0 ; i++) {
                        size_t ii = i + istart;
                        dis = hamming <nbits> (bs1_, bs2+ii * nwords);
                        maxheap_push<hamdis_t> (i+1, bh_val, bh_ids, dis, ii);
                    }
                    for (i = k0 ; i < k ; i++) {
                        bh_val[i] = INT_MAX;  /* ### check if not i+1 */
                        bh_ids[i] = -1;
                    }
                    posused[j] = k0;
                }

                for (i = istart; i < iend; i++) {
                    dis = hamming <nbits> (bs1_, bs2+i * nwords);
                    if (dis <= bh_val[0]) {
                        if (posused[j] < kit) {/* no extra -> incond. push */
                            posused[j]++;
                            maxheap_push<hamdis_t> (posused[j], bh_val, bh_ids,
                                                    dis, i);
                        }
                        else if (dis < bh_val[0]) {
                            maxheap_pop<hamdis_t> (kit, bh_val, bh_ids);
                            maxheap_push<hamdis_t> (kit, bh_val, bh_ids,
                                                    dis, i);
                        }
                    }
                }
            }
        }
    }
    delete [] ki;
    delete [] ti;
    delete [] posused;

    ha->reorder ();
}


/* Return closest neighbors w.r.t Hamming distance */
template <size_t nbits>
void hammings_knn_softradix (
        int_maxheap_array_t * ha,
         const uint64_t * bs1,
         const uint64_t * bs2,
         size_t n2,
         size_t blocksize,
         double delta,
         bool order = true)
{
    const size_t nwords = nbits / 64;
    size_t j, k = ha->k;
    size_t n1 = ha->nh;
    SET_NT (n1);

    const size_t T = (long) ceil (n2 / (double) blocksize);
    const size_t maxbufel = k + softheap_maxel (n2, k, T, delta);

    /* histograms counting number of elements for each Hamming distance,
       and this for each of the n1 queries */
    int M = nbits;
    long * hist_all = new long [n1 * (M+1)]();

    /* We maintain a threshold above which we do not consider the element */
    hamdis_t * ht_all = new hamdis_t[n1]();

    /* We also maintain in following table the number of elements that met
       the threshold. This number will increase every time one element passes
       the threshold, and will lowered every time the threshold is reduced */
    size_t * hist_at_ht = new size_t[n1]();
    for (size_t i = 0; i < n1; i++)
        ht_all[i] = M;

    /* We will be writing contiguously in buffers bufdis and bufids.
       Curent position for each query is stored in bufpos */
    hamdis_t * bufdis = new hamdis_t[n1 * maxbufel];
    long * bufids = new long[n1 * maxbufel];
    size_t * bufpos = new size_t[n1]();

    size_t * ki = new size_t[T];
    size_t * ti = new size_t[T];

    if (blocksize > n2)
        blocksize = n2;

    /* Initialization */
    size_t t;
    for (t = 0; t < T; t++)
        ti[t] = (t+1) * blocksize;
    ti[T-1] = n2;
    softheap_capacity (n2, k, T, ti, ki, delta);

    for (t = 0; t < T; t++) {
        const size_t istart = (t > 0 ? ti[t-1] : 0);
        const size_t iend = ti[t];
        const size_t kit = ki[t];

        #pragma omp parallel for private(j) num_threads(nt)
        for (j = 0; j < n1; j++) {
            hamdis_t * __restrict bufdisj = bufdis + j * maxbufel;
            long * __restrict bufidsj = bufids + j * maxbufel;
            const uint64_t * bs1j = bs1 + j * nwords;

            /* Use extra-variables to avoid de-referencing */
            size_t posbufj = bufpos[j];
            long * __restrict histj = hist_all + j * (M+1);
            size_t hist_at_htj = hist_at_ht[j];
            hamdis_t htj = ht_all[j];
            hamdis_t disji;

            size_t i;
            for (i = istart; i < iend && posbufj < maxbufel; i++) {
                disji = hamming <nbits> (bs1j, bs2 + i * nwords);
                if (disji <= htj) {
                    if (disji < htj || hist_at_htj < kit) {
                      bufdisj[posbufj] = disji;
                      bufidsj[posbufj++] = i;

                      histj[disji]++;
                      hist_at_htj++;

                      if (hist_at_htj > kit) {
                            /* Only useful at the initialization */
                            while (histj[htj] == 0)
                                htj--;
                            histj[htj]--;
                            hist_at_htj--;

                            /* Lower threshold if next test is positive */
                            while (histj[htj] == 0)
                            htj--;
                            assert (histj[htj] > 0);
                        }
                    }
                }
                assert (hist_at_htj <= kit);
            }
            hist_at_ht[j] = hist_at_htj;
            ht_all[j] = htj;
            bufpos[j] = posbufj;
        }
    }
    delete [] ti;
    delete [] ki;
    delete [] hist_at_ht;

    /* At this moment of the function,
       - bufpos[j] contains the number of elements stored for each query
       - hist contains the histogram (up to ham-distance disthres)
       - ht_all[j] is the latest distance threshold used. Note that, possibly,
         some elements with a larger distance may be kept in the buffer because
         of ties.
    */

    /* post-processing: keep only the best elements and put them in order
       We compute the cumulated histogram, which is used subsequently as
       position counter in the output buffer */


    #pragma omp parallel for private(j) num_threads(nt)
    for (j = 0; j < n1; j++) {
        long * __restrict histj = hist_all+j*(M+1);
        hamdis_t htj = ht_all[j];

        /* We cast the histogram to a cumulative histogram serving in turn as
           a position pointer for each possible Hamming value */
        size_t hprev = histj[0], hcur;
        long h;
        for (h = 1; h <= htj+1 ; h++) {
            hcur = histj[h];
            histj[h] = histj[h-1] + hprev;
            hprev = hcur;
        }

        const hamdis_t * __restrict bufdisj = bufdis + j * maxbufel;
        const long * __restrict bufidsj = bufids + j * maxbufel;
        hamdis_t * __restrict outdisj = ha->val + j * k;
        long * __restrict outidsj = ha->ids + j * k;

        size_t i, bufposj = bufpos[j], posout;
        hamdis_t disji;

        for (i = 0; i < bufposj; i++) {
            disji = bufdisj[i];
            posout = histj[disji];
            if (disji > htj)
                continue;
            if (posout >= k)
                continue;
            histj[disji]++;
            outdisj[posout] = disji;
            outidsj[posout] = bufidsj[i];
        }
    }
    delete [] hist_all;
    delete [] ht_all;
    delete [] bufpos;
    delete [] bufdis;
    delete [] bufids;

    ha->reorder ();
}


/* Count number of matches given a max threshold */
template <size_t nbits>
void hamming_count_thres (
        const uint64_t * bs1,
        const uint64_t * bs2,
        size_t n1,
        size_t n2,
        hamdis_t ht,
        size_t * nptr)
{
    const size_t nwords = nbits / 64;
    size_t i, j, posm = 0;
    const uint64_t * bs2_ = bs2;

    for (i = 0; i < n1; i++) {
        bs2 = bs2_;
        for (j = 0; j < n2; j++) {
            /* collect the match only if this satisfies the threshold */
            if (hamming <nbits> (bs1, bs2) <= ht)
                posm++;
            bs2 += nwords;
        }
        bs1 += nwords;  /* next signature */
    }
    *nptr = posm;
}


template <size_t nbits>
void crosshamming_count_thres (
        const uint64_t * dbs,
        size_t n,
        int ht,
        size_t * nptr)
{
    const size_t nwords = nbits / 64;
    size_t i, j, posm = 0;
    const uint64_t * bs1 = dbs;
    for (i = 0; i < n; i++) {
        const uint64_t * bs2 = bs1 + 2;
        for (j = i + 1; j < n; j++) {
            /* collect the match only if this satisfies the threshold */
            if (hamming <nbits> (bs1, bs2) <= ht)
                posm++;
            bs2 += nwords;
        }
        bs1 += nwords;
    }
    *nptr = posm;
}


template <size_t nbits>
size_t match_hamming_thres (
        const uint64_t * bs1,
        const uint64_t * bs2,
        size_t n1,
        size_t n2,
        int ht,
        long * idx,
        hamdis_t * hams)
{
    const size_t nwords = nbits / 64;
    size_t i, j, posm = 0;
    hamdis_t h;
    const uint64_t * bs2_ = bs2;
    for (i = 0; i < n1; i++) {
        bs2 = bs2_;
        for (j = 0; j < n2; j++) {
            /* Here perform the real work of computing the distance */
            h = hamming <nbits> (bs1, bs2);

            /* collect the match only if this satisfies the threshold */
            if (h <= ht) {
                /* Enough space to store another match ? */
                *idx = i; idx++;
                *idx = j; idx++;
                *hams = h;
                hams++;
                posm++;
            }
            bs2+=nwords;  /* next signature */
        }
        bs1+=nwords;
    }
    return posm;
}


/* Return closest neighbors w.r.t Hamming distance */
template <class HammingComputer>
static
void hammings_knn_hc (
        int bytes_per_code,
        int_maxheap_array_t * ha,
        const uint8_t * bs1,
        const uint8_t * bs2,
        size_t n2,
        bool order = true,
        bool init_heap = true)
{
    size_t k = ha->k;


    if (init_heap) ha->heapify ();

    /* The computation here does not involved any blockization,
       which is suboptimal for many queries in parallel.
       Invoke the softradix function with delta set to 1 to get it */
#pragma omp parallel for
    for (size_t i = 0; i < ha->nh; i++) {
        HammingComputer hc (bs1 + i * bytes_per_code, bytes_per_code);

        const uint8_t * bs2_ = bs2;
        hamdis_t dis;
        hamdis_t * __restrict bh_val_ = ha->val + i * k;
        long * __restrict bh_ids_ = ha->ids + i * k;
        size_t j;
        for (j = 0; j < n2; j++, bs2_+= bytes_per_code) {
            dis = hc.hamming (bs2_);
            if (dis < bh_val_[0]) {
                faiss::maxheap_pop<hamdis_t> (k, bh_val_, bh_ids_);
                faiss::maxheap_push<hamdis_t> (k, bh_val_, bh_ids_, dis, j);
            }
        }
    }
    if (order) ha->reorder ();
 }



// works faster than the template version
static
void hammings_knn_1 (
        int_maxheap_array_t * ha,
        const uint64_t * bs1,
        const uint64_t * bs2,
        size_t n2,
        bool order = true,
        bool init_heap = true)
{
    const size_t nwords = 1;
    size_t k = ha->k;


    if (init_heap) {
        ha->heapify ();
    }

#pragma omp parallel for
    for (size_t i = 0; i < ha->nh; i++) {
        const uint64_t bs1_ = bs1 [i];
        const uint64_t * bs2_ = bs2;
        hamdis_t dis;
        hamdis_t * bh_val_ = ha->val + i * k;
        hamdis_t bh_val_0 = bh_val_[0];
        long * bh_ids_ = ha->ids + i * k;
        size_t j;
        for (j = 0; j < n2; j++, bs2_+= nwords) {
            dis = popcount64 (bs1_ ^ *bs2_);
            if (dis < bh_val_0) {
                faiss::maxheap_pop<hamdis_t> (k, bh_val_, bh_ids_);
                faiss::maxheap_push<hamdis_t> (k, bh_val_, bh_ids_, dis, j);
                bh_val_0 = bh_val_[0];
            }
        }
    }
    if (order) {
        ha->reorder ();
    }
}




/* Functions to maps vectors to bits. Assume proper allocation done beforehand,
   meaning that b should be be able to receive as many bits as x may produce. */

/*
 * dimension 0 corresponds to the least significant bit of b[0], or
 * equivalently to the lsb of the first byte that is stored.
 */
void fvec2bitvec (const float * x, uint8_t * b, size_t d)
{
    for (int i = 0; i < d; i += 8) {
        uint8_t w = 0;
        uint8_t mask = 1;
        int nj = i + 8 <= d ? 8 : d - i;
        for (int j = 0; j < nj; j++) {
            if (x[i + j] >= 0)
                w |= mask;
            mask <<= 1;
        }
        *b = w;
        b++;
    }
}



/* Same but for n vectors.
   Ensure that the ouptut b is byte-aligned (pad with 0s). */
void fvecs2bitvecs (const float * x, uint8_t * b, size_t d, size_t n)
{
    const long ncodes = ((d + 7) / 8);
#pragma omp parallel for
    for (size_t i = 0; i < n; i++)
        fvec2bitvec (x + i * d, b + i * ncodes, d);
}


/* Reverse bit (NOT a optimized function, only used for print purpose) */
static uint64_t uint64_reverse_bits (uint64_t b)
{
    int i;
    uint64_t revb = 0;
    for (i = 0; i < 64; i++) {
        revb <<= 1;
        revb |= b & 1;
        b >>= 1;
    }
    return revb;
}


/* print the bit vector */
void bitvec_print (const uint8_t * b, size_t d)
{
    size_t i, j;
    for (i = 0; i < d; ) {
        uint64_t brev = uint64_reverse_bits (* (uint64_t *) b);
        for (j = 0; j < 64 && i < d; j++, i++) {
            printf ("%d", (int) (brev & 1));
            brev >>= 1;
        }
        b += 8;
        printf (" ");
    }
}





/*----------------------------------------*/
/* Hamming distance computation and k-nn  */


#define C64(x) ((uint64_t *)x)


/* Compute a set of Hamming distances */
void hammings (
        const uint8_t * a,
        const uint8_t * b,
        size_t na, size_t nb,
        size_t ncodes,
        hamdis_t * __restrict dis)
{
    FAISS_ASSERT (ncodes % 8 == 0);
    switch (ncodes) {
        case 8:
            faiss::hammings <64>  (C64(a), C64(b), na, nb, dis); return;
        case 16:
            faiss::hammings <128> (C64(a), C64(b), na, nb, dis); return;
        case 32:
            faiss::hammings <256> (C64(a), C64(b), na, nb, dis); return;
        case 64:
            faiss::hammings <512> (C64(a), C64(b), na, nb, dis); return;
        default:
            faiss::hammings (C64(a), C64(b), na, nb, ncodes * 8, dis); return;
    }
}


void hammings_knn_core (
        int_maxheap_array_t * ha,
        const uint8_t * a,
        const uint8_t * b,
        size_t nb,
        size_t ncodes)
{
    FAISS_ASSERT (ncodes % 8 == 0);

    switch (ncodes) {
        hammings_knn_1 (ha, C64(a), C64(b), nb, false, true);
        // hammings_knn_hc<faiss::HammingComputer8> (8, ha, a, b, nb, false, true);
        break;
    case 16:
        hammings_knn_hc<faiss::HammingComputer16> (16, ha, a, b, nb, false, true);
        break;
    case 32:
        hammings_knn_hc<faiss::HammingComputer32> (32, ha, a, b, nb, false, true);
        break;
    default:
        hammings_knn_hc<faiss::HammingComputerM8> (ncodes, ha, a, b, nb, false, true);
    }
}

void hammings_knn (
        int_maxheap_array_t * ha,
        const uint8_t * a,
        const uint8_t * b,
        size_t nb,
        size_t ncodes,
        int order)
{
    switch (ncodes) {
    case 4:
        hammings_knn_hc<faiss::HammingComputer4> (4, ha, a, b, nb, order, true);
        break;
    case 8:
        hammings_knn_1 (ha, C64(a), C64(b), nb, order, true);
        // hammings_knn_hc<faiss::HammingComputer8> (8, ha, a, b, nb, order, true);
        break;
    case 16:
        hammings_knn_hc<faiss::HammingComputer16> (16, ha, a, b, nb, order, true);
        break;
    case 32:
        hammings_knn_hc<faiss::HammingComputer32> (32, ha, a, b, nb, order, true);
        break;
    default:
        FAISS_ASSERT (ncodes % 8 == 0);
        hammings_knn_hc<faiss::HammingComputerM8> (ncodes, ha, a, b, nb, order, true);

    }
}


void hammings_knn_softheap (
         int_maxheap_array_t * ha,
         const uint8_t * a,
         const uint8_t * b,
         size_t nb,
         size_t ncodes,
         int order,
         size_t blocksize,
         double delta)
{

    switch (ncodes) {
        case 8:
            faiss::hammings_knn_softheap <64>  (ha, C64(a), C64(b),
                                         nb, blocksize, delta, order);
            break;
        case 16:
            faiss::hammings_knn_softheap <128> (ha, C64(a), C64(b),
                                         nb, blocksize, delta, order);
            break;
        case 32:
            faiss::hammings_knn_softheap <256> (ha, C64(a), C64(b),
                                         nb, blocksize, delta, order);
            break;
        case 64:
            faiss::hammings_knn_softheap <512> (ha, C64(a), C64(b),
                                         nb, blocksize, delta, order);
            break;
        default:
            FAISS_ASSERT (!"not-implemented for this number of bits");
    }
}


void hammings_knn_softradix (
        int_maxheap_array_t * ha,
        const uint8_t * a,
        const uint8_t * b,
        size_t nb,
        size_t ncodes,
        int order,
        size_t blocksize,
        double delta)
{
    switch (ncodes) {
        case 8:
            faiss::hammings_knn_softradix <64>  (ha, C64(a), C64(b),
                                          nb, blocksize, delta, true);
            break;
        case 16:
            faiss::hammings_knn_softradix <128> (ha, C64(a), C64(b),
                                          nb, blocksize, delta, true);
            break;
        case 32:
            faiss::hammings_knn_softradix <256> (ha, C64(a), C64(b),
                                          nb, blocksize, delta, true);
            break;
        case 64:
            faiss::hammings_knn_softradix <512> (ha, C64(a), C64(b),
                                          nb, blocksize, delta, true);
            break;
        default:
            FAISS_ASSERT (!"not-implemented for this number of bits");
    }
}


/* Count number of matches given a max threshold            */
void hamming_count_thres (
        const uint8_t * bs1,
        const uint8_t * bs2,
        size_t n1,
        size_t n2,
        hamdis_t ht,
        size_t ncodes,
        size_t * nptr)
{
    switch (ncodes) {
        case 8:
            faiss::hamming_count_thres <64> (C64(bs1), C64(bs2),
                                             n1, n2, ht, nptr);
            return;
        case 16:
            faiss::hamming_count_thres <128> (C64(bs1), C64(bs2),
                                              n1, n2, ht, nptr);
            return;
        case 32:
            faiss::hamming_count_thres <256> (C64(bs1), C64(bs2),
                                              n1, n2, ht, nptr);
            return;
        case 64:
            faiss::hamming_count_thres <512> (C64(bs1), C64(bs2),
                                              n1, n2, ht, nptr);
            return;
        default:
            FAISS_ASSERT (!"not-implemented for this number of bits");
    }
}


/* Count number of cross-matches given a threshold */
void crosshamming_count_thres (
        const uint8_t * dbs,
        size_t n,
        hamdis_t ht,
        size_t ncodes,
        size_t * nptr)
{
    switch (ncodes) {
        case 8:
            faiss::crosshamming_count_thres <64>  (C64(dbs), n, ht, nptr);
            return;
        case 16:
            faiss::crosshamming_count_thres <128> (C64(dbs), n, ht, nptr);
            return;
        case 32:
            faiss::crosshamming_count_thres <256> (C64(dbs), n, ht, nptr);
            return;
        case 64:
            faiss::crosshamming_count_thres <512> (C64(dbs), n, ht, nptr);
            return;
        default:
            FAISS_ASSERT (!"not-implemented for this number of bits");
    }
}


/* Returns all matches given a threshold */
size_t match_hamming_thres (
        const uint8_t * bs1,
        const uint8_t * bs2,
        size_t n1,
        size_t n2,
        hamdis_t ht,
        size_t ncodes,
        long * idx,
        hamdis_t * dis)
{
    switch (ncodes) {
        case 8:
          return faiss::match_hamming_thres <64> (C64(bs1), C64(bs2),
                                                  n1, n2, ht, idx, dis);
        case 16:
          return faiss::match_hamming_thres <128> (C64(bs1), C64(bs2),
                                                   n1, n2, ht, idx, dis);
        case 32:
          return faiss::match_hamming_thres <256> (C64(bs1), C64(bs2),
                                                   n1, n2, ht, idx, dis);
        case 64:
          return faiss::match_hamming_thres <512> (C64(bs1), C64(bs2),
                                                   n1, n2, ht, idx, dis);
        default:
            FAISS_ASSERT (!"not-implemented for this number of bits");
    }
}


#undef C64



/*************************************
 * generalized Hamming distances
 ************************************/



template <class HammingComputer>
static void hamming_dis_inner_loop (
        const uint8_t *ca,
        const uint8_t *cb,
        size_t nb,
        size_t code_size,
        int k,
        hamdis_t * bh_val_,
        long *     bh_ids_)
{

    HammingComputer hc (ca, code_size);

    for (size_t j = 0; j < nb; j++) {
        int ndiff = hc.hamming (cb);
        cb += code_size;
        if (ndiff < bh_val_[0]) {
            maxheap_pop<hamdis_t> (k, bh_val_, bh_ids_);
            maxheap_push<hamdis_t> (k, bh_val_, bh_ids_, ndiff, j);
        }
    }
}

void generalized_hammings_knn (
        int_maxheap_array_t * ha,
        const uint8_t * a,
        const uint8_t * b,
        size_t nb,
        size_t code_size,
        int ordered)
{
    int na = ha->nh;
    int k = ha->k;

    if (ordered)
        ha->heapify ();

#pragma omp parallel for
    for (int i = 0; i < na; i++) {
        const uint8_t *ca = a + i * code_size;
        const uint8_t *cb = b;

        hamdis_t * bh_val_ = ha->val + i * k;
        long *     bh_ids_ = ha->ids + i * k;

        switch (code_size) {
        case 8:
            hamming_dis_inner_loop<GenHammingComputer8>
                (ca, cb, nb, 8, k, bh_val_, bh_ids_);
            break;
        case 16:
            hamming_dis_inner_loop<GenHammingComputer16>
                (ca, cb, nb, 16, k, bh_val_, bh_ids_);
            break;
        case 32:
            hamming_dis_inner_loop<GenHammingComputer32>
                (ca, cb, nb, 32, k, bh_val_, bh_ids_);
            break;
        default:
            hamming_dis_inner_loop<GenHammingComputerM8>
                (ca, cb, nb, code_size, k, bh_val_, bh_ids_);
            break;
        }
    }

    if (ordered)
        ha->reorder ();

}





} // namespace faiss
